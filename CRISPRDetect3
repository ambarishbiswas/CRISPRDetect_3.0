#!/usr/bin/perl 
our $version="3.0";


use strict;
use Term::ANSIColor;

use FindBin qw($Bin);
use lib "$Bin/lib";
require "$Bin/CD_MODULES/CRISPRDETECT_SUBS_1.pm";

our $cd_path=$Bin;

#------------------------------------------------------------------------------------------------------------------------------------------------
#Program : 	CRISPRDetect_3.0
#Author: 	Ambarish Biswas
#Contact:	Ambarish Biswas [ambarishbiswas@gmail.com]
#------------------------------------------------------------------------------------------------------------------------------------------------
###### CRISPRDetect_3.0 supports a range of parameters passed through command line without changing this script. 
###### The parameters are named in relation to the function/module it is related with. For example, the parameter 
###### 		'extend_array' is associated with extending the CRISPR arrays, which uses 'ea_allowed_percent_similarity' and 
###### 		'ea_dynamic_search'. Note the 'ea_' in the beginning which is abbreviated from 'extend array'. The parameters are
###### 		listed in the order of the modules listed in the CRISPRDetect webserver, and can be easily understood by comparing with the website.
#------------------------------------------------------------------------------------------------------------------------------------------------







#our $tmp_dir="$cd_path/tmp";
our $tmp_dir="/tmp";
my $no_of_threads=4;


use Parallel::ForkManager;
my $pm = new Parallel::ForkManager($no_of_threads);      # specify the number of parallel processes CRISPRDetect should use. Defaults to 4.





############## Note: absolutely important for CRISPRDetect_web application that my $keep_input_sequences=1 should be used, or the interactive modules will fail  #####
my $keep_input_sequences=0;

######################################################################################################################################################################






#----- before running check all dependencies are installed -----------------------------------------------------------------------------

my($clustalw_found,$water_found,$seqret_found,$RNAfold_found,$cd_hit_found,$blastn_found)=&check_executables_required_for_CRISPRDetect(); #----- check the required 3rd party executables ------
if($clustalw_found=~/^Not found/ or $water_found=~/^Not found/ or $seqret_found=~/^Not found/ or $RNAfold_found=~/^Not found/ or $cd_hit_found=~/^Not found/ or $blastn_found=~/^Not found/)
	{
		print "\nError: Some of the dependencies not found in system path. Program terminating.\n"; exit;
	}
if(not -d $tmp_dir)
	{		
		system("mkdir -p $tmp_dir");system("chmod 775 $tmp_dir");
	}








#***************************** new input parameters [for version 2.3] **********************************************************************************

our $wgs=1;
my $annotate_cas_genes=0;
my $hmm_seq_evalue_cutoff=0.01;#0.00001; # -E 1e-5 
my $hmm_dom_evalue_cutoff=0.01;;#0.00001; # -E 1e-5 

our $check_plasmid=0;
#******************************************************** change the parameters for initial (putative) CRISPR prediction *****************************************


my $array_quality_score_cutoff=3;

my $word_length=11;
my $minimum_word_repeatation=3;


#-------------------------------- filtering option
my $repeat_length_cutoff=17;

my $minimum_no_of_repeats=3;
my $minimum_repeat_length=23;


############################## Formatting parameters ######################################################################################################################################




my $max_gap_between_crisprs=500;

my $left_flank_length=500;
my $right_flank_length=500;






my $continue_from_last_process=0;
my $continue_from_last_process_file="already_processed_sequences.list";







#-------------------------------- first turn on/off specific modules auto execution using these control parameters
my $minimum_spacer_gap=50-$word_length;
my $maximum_spacer_gap=100+$word_length;


my $remove_insertion_from_repeat=1;

my $fix_gaps_in_repeats=1;

my $extend_array=1;
	my $ea_allowed_percent_similarity=67;
	my $ea_dynamic_search=1;

my $search_unidentified_repeat_in_spacer_sequence=1;
	my $allowed_percent_similarity=67;	
	my $su_dynamic_search=0;
	
my $trim_repeats=1;
	my $trimming_cutoff="AUTO";
	my $user_side_to_trim="NA";
	my $user_no_of_bases_to_trim=0;


my $increase_repeat_length=1;
	my $repeat_extension_identity="AUTO";    		#-- default >50% --------------------
	my $user_side_to_increase_length="NA";
	my $user_no_of_bases_to_increase_length=0;
	
	
my $shorten_array=1;
	my $user_side_to_shorten="NA";
	my $sa_allowed_percent_similarity=66;


my $check_consensus=1;						# ---by default set to 1


my $find_alternate_repeat=1;				# ---default set to 1 
	my $potential_alternate_repeat="NA";


my $check_direction=1;						# ---default set to 1 

	#-------------------------- change the parameters for directional analysis directional analysis (CRISPRDirection) ----------------------------------------------------------------------------

	my $check_motif_in_repeat=1; 
		my $Motif_match_score=4.50;			# Default: Score 4.5 (acts as a fileter); If you choose to use this method like the other methods make the score 0.50 [i.e. PPV (1) - 0.50];
		my $motif="ATTGAAA.?";				# Default: "ATTGAAA.?" where '.?' is equal to N, another example is "A.?.?TGAAA[C|G]" which is same as ANNTGAAAC or ANNTGAAAG 

	my $check_A_and_T_ratio_in_repeat=1;
		my $A_and_T_ratio_score=0.37;		# Default: PPV (0.87) - 0.50
		
	my $check_similarity_with_reference_repeat=1; 
		my $Similarity_score=4.50;			# Default: Score 0.50 [i.e. PPV (1) - 0.50]; If you want to make it act as a filter use Score 4.5 or higher; 	
		my $allowed_no_of_mismatches=3;		# Default 3		#Note: We noticed upto allowed 6 bases mismatch there were no false predictions (Refer paper/supplement)
		
	my $check_secondary_structure_of_repeat=1;		
		my $MFE_score=0.37;					# Default: PPV (0.87) - 0.50		
		my $MFE_cutoff=1;					# Default 1
		my $MFE_minimum_difference=0.25;	# Default 0.25
		my $MFE_exclude_bases=5;			# Default 5	

	my $check_array_degeneracy=1;	 
		my $array_degeneracy_score=0.41;	# Default: PPV (0.91) - 0.50
		my $permitted_mutation_per_array=0;	# Default 0

	my $check_AT_distribution_in_flanks=1; 
		my $AT_distribution_score=0.27;		# Default: PPV (0.77) - 0.50
		my $AT_distribution_window=60;		# Default: 60
		my $AT_distribution_minimum_percentage_difference=10;	# Default: 10 


	my $check_longer_leader=1;
		my $Longer_leader_score=0.18;		# Default: PPV (0.68) - 0.50



my $user_reverse_the_array=0;					# ---default set to 0

###################################################################### end of optional user input section #####################################################


































##################################################################### do not change anyting below this, unless you know what you doing #######################################################







#--------- open library of repeats with confirmed direction -----------------------
my %lib_of_repeats_with_confirmed_direction;				
open(LIB_REP,"$cd_path/Ref_lib_files/verified_repeats_with_family.txt") or print "$!";
my @arr_ref_lib=<LIB_REP>;
close(LIB_REP);
				
foreach my $ref_line(@arr_ref_lib)
	{
		if($ref_line=~/^#/){next;}  # skip the comment lines if any
		
		chomp $ref_line;$ref_line=~s/\r//g;
		my($rep,$fam_type)=split('\t',$ref_line);
		my $translated_rep=$rep; $translated_rep=~tr/T/U/;
		$lib_of_repeats_with_confirmed_direction{$rep}=$fam_type;
		$lib_of_repeats_with_confirmed_direction{$translated_rep}=$fam_type;
	}


my $blast_db_file_of_known_repeats="$cd_path/BLAST_DB_OF_KNOWN_REPEATS/known_repeats.fa";





#---------------------------------------------------------------------------------------

#my $input_array_file;

my $all_gene_positions_folder="$tmp_dir\/";
#my $all_gene_positions_file="NA";

my $output_file="$tmp_dir\/CRISPRDetect_output_".&get_unique_id().".txt";
my $ref_lib_file="NA";
my $gff_file="NA";
my $filtered_out_crisprs="NA";















my $quiet=0;

my $species="Bacteria";


my $idnumber=&get_unique_id();

my $all_gene_positions_file="NA";#$idnumber."_CDS_ positions.txt"; open(WR,">$tmp_dir\/$all_gene_positions_file");close(WR);

my $input_sequence_file=$idnumber."_fasta_sequence.txt";
#my $output_file;
my @arr_sequence_files;
our %hash_id_lookup_table;
my %hash_of_accession_and_species;


my $repeats_file=$idnumber."_repeats.txt";;
my $process_repeats_only=0;

my $array_seq_range="NA";

our %hash_of_seq_id_and_seq;

#------ step 0: get the input file ----------------------------------------
if(not defined $ARGV[0]){&show_help($clustalw_found,$water_found,$seqret_found,$RNAfold_found,$cd_hit_found,$blastn_found);exit;}

my $output_file_specified=0;


#---- first check if a tmp_dir is specified ---
for(my $i=0;$i<=$#ARGV;$i++)
	{		
		if($ARGV[$i]=~/-tmp_dir/)
			{
				$tmp_dir=$ARGV[$i+1];
				if(not -d $tmp_dir)
					{
						print "\nError: The specified directory: $tmp_dir not found. User should create the directory, and give read and write permission to perl and its dependent tools. Best to use the default '/tmp' directory.\n\n";exit;
					}													
			}
	 }
	 

###################################################################---- create a folder for temporary files : which will be deleted once the process is finished ################
$tmp_dir="$tmp_dir/$idnumber";	 	

unless(-d $tmp_dir)
	{		
		system("mkdir -p $tmp_dir");system("chmod -R 777 $tmp_dir");
	}
#print "*** $tmp_dir ***\n";
######################################################################








#---- then get the other parameters ---
for(my $i=0;$i<=$#ARGV;$i++)
	{		
		if($ARGV[$i]=~/-keep_input_sequences/)
			{
				$keep_input_sequences=$ARGV[$i+1];					
				$keep_input_sequences=abs(int($keep_input_sequences));								
			}
		elsif($ARGV[$i]=~/-quiet$/)	#------ silencing the program's step by step reporting
			{
				$quiet=$ARGV[$i+1];					
				$quiet=abs(int($quiet));								
			}
		elsif($ARGV[$i]=~/-q$/)
			{
				$quiet=$ARGV[$i+1];					
				$quiet=abs(int($quiet));								
			}
		elsif($ARGV[$i]=~/-wgs/i)
			{
				$wgs=$ARGV[$i+1];					
			}						
		elsif($ARGV[$i]=~/-annotate_cas_genes/)
			{
				$annotate_cas_genes=$ARGV[$i+1];					
			}
		elsif($ARGV[$i]=~/-hmm_seq_evalue_cutoff/)
			{
				$hmm_seq_evalue_cutoff=$ARGV[$i+1];					
			}
		elsif($ARGV[$i]=~/-hmm_dom_evalue_cutoff/)
			{
				$hmm_dom_evalue_cutoff=$ARGV[$i+1];					
			}			
		elsif($ARGV[$i]=~/-check_plasmid/)
			{
				$check_plasmid=$ARGV[$i+1];	
				
				
				my $plasmid_blast_db_file="$cd_path/REFSEQ_PLASMIDS_DB/plasmids.fa";	
				
				if($check_plasmid >0 && not -e $plasmid_blast_db_file)
					{
						print color ('bold red');
						print qq~Warning: -check_plasmid option selected but RefSeq plasmid DB files are missing. Please either specify '-check_plasmid 0' or run the following command to build the Reference plasmid DB:
~;
						print color('reset');
						print color ('bold blue');
						print qq~
perl $cd_path/script_make_plasmid_db.pl

~;						
						print color('reset');
						
						exit;
					}
								
			}			
		elsif($ARGV[$i]=~/-all_gene_positions_file/)
				{
					$all_gene_positions_file=$ARGV[$i+1];					
				}
		elsif($ARGV[$i]=~/-ref_lib_file/)
				{
					$ref_lib_file=$ARGV[$i+1];	
					chomp $ref_lib_file; $ref_lib_file=~s/\r//g;	
					
					#print "Found ref_lib_file\n\n";	
					
					if(-e $ref_lib_file and $ref_lib_file!~/NA/)
						{
							#print "\n\n\$ref_lib_file= $ref_lib_file\n\n";
							open(LIB_REP,"$ref_lib_file") or print "$!";
							my @arr_ref_lib=<LIB_REP>;
							close(LIB_REP);
							
							#--- now create a blast_db_of_known_repeats.fa file	
							my $tmp_blast_db_file_of_known_repeats="$tmp_dir\/".&get_unique_id()."_known_repeats.fa";	
							
							system("cat $blast_db_file_of_known_repeats >$tmp_blast_db_file_of_known_repeats");
							
							open(UR,">>$tmp_blast_db_file_of_known_repeats");					
							my $user_repeat_index=0;
							foreach my $ref_line(@arr_ref_lib)
								{
									if($ref_line=~/^#/){next;}  # skip the comment lines if any
									$user_repeat_index++;
									
									
									chomp $ref_line;$ref_line=~s/\r//g;
									
									my($rep,$fam_type)=split('\t',$ref_line);
									#print "$ref_line: [$rep,$fam_type]\n";
									my $translated_rep=$rep; $translated_rep=~tr/T/U/;
									$lib_of_repeats_with_confirmed_direction{$rep}=$fam_type;
									$lib_of_repeats_with_confirmed_direction{$translated_rep}=$fam_type;
									
									if($fam_type=~/\S{1,}/)
										{
											$fam_type=~s/_/-/g;
											print UR ">UR_$user_repeat_index\_$fam_type\n$rep\n";
											#print ">UR_$user_repeat_index\_$fam_type\n$rep\n";
										}
									else{	
											print UR ">UR_$user_repeat_index\_USER-REPEAT\n$rep\n";
										}	
								}
							close(UR);			
							
							
							#--- now make a blast DB
							system("makeblastdb -in $tmp_blast_db_file_of_known_repeats -dbtype nucl -hash_index >/dev/null 2>/dev/null");
								
							#---- now update the $blast_db_file_of_known_repeats
							$blast_db_file_of_known_repeats=$tmp_blast_db_file_of_known_repeats;	
							
							#print "\nNew \$blast_db_file_of_known_repeats= $blast_db_file_of_known_repeats\n\n";
						}
					
						
				}		
		#------ set the no. of parallel processes
		elsif($ARGV[$i]=~/-T$/)
			{
				$no_of_threads=$ARGV[$i+1];
				$no_of_threads=int($no_of_threads);	
				
				if(-e "/proc/cpuinfo")
					{				
						my $no_of_system_cpus=`grep -F 'processor' /proc/cpuinfo | wc -l >&1`;
						chomp $no_of_system_cpus; $no_of_system_cpus=~s/\r//g;
						$no_of_system_cpus=int($no_of_system_cpus);
						
						if($no_of_system_cpus >1)
						{
							if($no_of_threads < $no_of_system_cpus)
								{
									#-- sweet
									if($no_of_threads ==0)
										{
											$no_of_threads=$no_of_system_cpus-1;
										}
								}
							elsif($no_of_threads>=$no_of_system_cpus)
								{
									$no_of_threads=$no_of_system_cpus-1;								
								}
							else{
									$no_of_threads=1;
								}	
						}	
					}
				else{
						$no_of_threads=1;
					}	
				
				#--- now reinitiate the $pm
				$pm = new Parallel::ForkManager($no_of_threads);		
								
			}
				
			
		#--------------------------- search CRISPR-Hotspots ---------------------------------------------------
		elsif($ARGV[$i]=~/-word_length$/)
			{
				$word_length=$ARGV[$i+1];	
				
				$word_length=abs(int($word_length));
				
				if($word_length<6){$word_length=6;}
				
				$minimum_spacer_gap=50-$word_length;
				$maximum_spacer_gap=100+$word_length;				
			}
		elsif($ARGV[$i]=~/-minimum_word_repeatation$/)
			{
				$minimum_word_repeatation=$ARGV[$i+1];					
			}		
		#--------------------------- input options ------------------------------------------------------------
		elsif($ARGV[$i]=~/-minimum_no_of_repeats/)
			{
				$minimum_no_of_repeats=$ARGV[$i+1];					
			}
		elsif($ARGV[$i]=~/-repeat_length_cutoff/)
			{
				$repeat_length_cutoff=$ARGV[$i+1];					
			}	
			
		elsif($ARGV[$i]=~/-f$/)
			{
				#----- input is a fasta file ------------------------------------------------------------------
				my $tmp_file=$ARGV[$i+1];
				
				#--- now copy the sequence from $source_fasta_file to tmp/$input_sequence_file
				&process_fasta_file($tmp_file,\@arr_sequence_files,\%hash_id_lookup_table,\%hash_of_seq_id_and_seq);
			}
		elsif($ARGV[$i]=~/-g$/)
			{
				#----- input is a gbk file : first extract sequence from it------------------------------------
				my $filename=$ARGV[$i+1];			

				#----------------------------------------------------------------------------------------------
				
				
				if($filename=~/\.gbk$/)
					{
						my($accession,$defination,$species)=&extract_information_and_sequence_from_gbk_file($filename,\@arr_sequence_files,\%hash_id_lookup_table,\%hash_of_seq_id_and_seq);	
						print "\n$accession,$defination,$species\n";						

						push(@arr_sequence_files,$accession);
						$hash_id_lookup_table{$accession}="$accession $defination";	
						$hash_of_accession_and_species{$accession}=$species;
						##------------ get the accession ---------------------------------------------------------------
						#&process_fasta_file($tmp_file,\@arr_sequence_files,\%hash_id_lookup_table);		
						
								
						#----------- now get the gene positions -------------------------------------------------------
						if($all_gene_positions_file eq "NA")
							{
								$all_gene_positions_file=&get_unique_id()."$accession\_CDS_positions.txt";							
							}			
						&process_gbk_file($filename,$all_gene_positions_file);
						#---------------------------------------------------------------------------------------------- 
					}
				elsif($filename=~/\.gb$/)
					{
						my($accession,$defination,$species)=&extract_information_and_sequence_from_gbk_file($filename,\@arr_sequence_files,\%hash_id_lookup_table,\%hash_of_seq_id_and_seq);							

						push(@arr_sequence_files,$accession);
						$hash_id_lookup_table{$accession}="$accession $defination";	
						$hash_of_accession_and_species{$accession}=$species;
						##------------ get the accession ---------------------------------------------------------------
						#&process_fasta_file($tmp_file,\@arr_sequence_files,\%hash_id_lookup_table);		
						
								
						#----------- now get the gene positions -------------------------------------------------------
						if($all_gene_positions_file eq "NA")
							{
								$all_gene_positions_file=&get_unique_id()."_CDS_positions.txt";							
							}			
						&process_gbk_file($filename,$all_gene_positions_file);
						#----------------------------------------------------------------------------------------------
					}	
				elsif($filename=~/\.gbff$/)
					{
						#----split the gbff file to multiple contigs file
						my @arr_gbk_files;
						&split_gbff_file_to_individual_gbk_files($filename,\@arr_gbk_files);
						
						foreach my $gbk_file(@arr_gbk_files)
							{
								#print "$gbk_file\n";
								my($accession,$defination,$species)=&extract_information_and_sequence_from_gbk_file($gbk_file,\@arr_sequence_files,\%hash_id_lookup_table,\%hash_of_seq_id_and_seq);								

								push(@arr_sequence_files,$accession);
								
								$hash_id_lookup_table{$accession}="$accession $defination";	
								$hash_of_accession_and_species{$accession}=$species;
								##------------ get the accession ---------------------------------------------------------------
								#&process_fasta_file($tmp_file,\@arr_sequence_files,\%hash_id_lookup_table);		
								
										
								#----------- now get the gene positions -------------------------------------------------------
								if($all_gene_positions_file eq "NA")
									{
										$all_gene_positions_file=&get_unique_id()."$accession\_CDS_positions.txt";							
									}			
								&process_gbk_file($gbk_file,$all_gene_positions_file);
								#----------------------------------------------------------------------------------------------
								
								unlink($gbk_file);
							}
							
					}
			}		
		elsif($ARGV[$i]=~/-r$/)
			{
				#----- input is a directory of GBK files  ---------------------------------------------------
				my $gbk_folder=$ARGV[$i+1];
				
				my @all_gbk_files=`find $gbk_folder -name '*.gbk' >&1`;
				
				my $total_gbk_files_to_process=$#all_gbk_files+1;
				print "Total $#all_gbk_files to process...\n";
				
				foreach my $gbk_file(@all_gbk_files)
						{
								chomp $gbk_file; $gbk_file=~s/\r//;
								#print "$gbk_file\n";
								my($accession,$defination,$species)=&extract_information_and_sequence_from_gbk_file($gbk_file,\@arr_sequence_files,\%hash_id_lookup_table,\%hash_of_seq_id_and_seq);								

								push(@arr_sequence_files,$accession);
								
								$hash_id_lookup_table{$accession}="$accession $defination";	
								$hash_of_accession_and_species{$accession}=$species;
								##------------ get the accession ---------------------------------------------------------------
								#&process_fasta_file($tmp_file,\@arr_sequence_files,\%hash_id_lookup_table);		
								
										
								#----------- now get the gene positions -------------------------------------------------------
								if($all_gene_positions_file eq "NA")
									{
										$all_gene_positions_file=&get_unique_id()."$accession\_CDS_positions.txt";							
									}			
								&process_gbk_file($gbk_file,$all_gene_positions_file);
								#----------------------------------------------------------------------------------------------
								
								#unlink($gbk_file); #--- don't delete the source files here
						}
			}	
		
		elsif($ARGV[$i]=~/-continue$/)
			{
				#print "Continue set to true\n\n";
				#----- input is a fasta file ------------------------------------------------------------------
				$continue_from_last_process=$ARGV[$i+1];
				if($continue_from_last_process==0 or not -e "$tmp_dir\/$continue_from_last_process_file")
					{
						open(CLEAR,">$tmp_dir\/$continue_from_last_process_file") or print "$!\n";close(CLEAR);
					}
			}
		#--------- output options -----------------------------------------------------------------------------
		elsif($ARGV[$i]=~/-o$/)
			{
				#----- input is a fasta repeat(s) only file ---------------------------------------------------
				$output_file=$ARGV[$i+1];
				
				
				if(not defined $ARGV[$i+1])
					{
						print "\nWrong input. A filename is expected after -o [e.g. -o output.txt]\n\n";
						exit;
					}
				else{
						open(WR,">$output_file") or print "$!";close(WR);system("chmod 777 $output_file");
						
						$gff_file=$output_file.".gff";
						open(WR,">$gff_file") or print "$!";close(WR);system("chmod 777 $gff_file");
						
						$filtered_out_crisprs=$output_file.".fp";
						open(WR,">$filtered_out_crisprs") or print "$!";close(WR);system("chmod 777 $filtered_out_crisprs");
					}	
				$output_file_specified=1;	
			}
		#----------------------------------------------------------			
	
			#-----------------------------------------------------------	
			elsif($ARGV[$i]=~/-species/)
				{
					$species=$ARGV[$i+1];					
				}	
				
			elsif($ARGV[$i]=~/-left_flank_length/)
				{
					$left_flank_length=$ARGV[$i+1];					
				}
			elsif($ARGV[$i]=~/-right_flank_length/)
				{
					$right_flank_length=$ARGV[$i+1];					
				}	
			elsif($ARGV[$i]=~/-max_gap_between_crisprs/)
				{
					$max_gap_between_crisprs=$ARGV[$i+1];					
				}				
				
			#--------------	
			elsif($ARGV[$i]=~/-remove_insertion_from_repeat/)
				{
					$remove_insertion_from_repeat=$ARGV[$i+1];					
				}
				
			elsif($ARGV[$i]=~/-extend_array/)
				{
					$extend_array=$ARGV[$i+1];					
				}
			elsif($ARGV[$i]=~/-ea_allowed_percent_similarity/)
				{
					$ea_allowed_percent_similarity=$ARGV[$i+1];					
				}
			elsif($ARGV[$i]=~/-ea_dynamic_search/)
				{
					$ea_dynamic_search=$ARGV[$i+1];					
				}
					
			elsif($ARGV[$i]=~/-fix_gaps_in_repeats/)
				{
					$fix_gaps_in_repeats=$ARGV[$i+1];					
				}
				
			elsif($ARGV[$i]=~/-search_unidentified_repeat_in_spacer_sequence/)
				{
					$search_unidentified_repeat_in_spacer_sequence=$ARGV[$i+1];					
				}
			elsif($ARGV[$i]=~/-su_dynamic_search/)
				{
					$su_dynamic_search=$ARGV[$i+1];					
				}	
				
			elsif($ARGV[$i]=~/-allowed_percent_similarity/)
				{
					$allowed_percent_similarity=$ARGV[$i+1];					
				}				
			elsif($ARGV[$i]=~/-trim_repeats/)
				{
					$trim_repeats=$ARGV[$i+1];					
				}
			elsif($ARGV[$i]=~/-minimum_repeat_length/)
				{
					$minimum_repeat_length=$ARGV[$i+1];					
				}	
				
			elsif($ARGV[$i]=~/-trimming_cutoff/)
				{
					$trimming_cutoff=$ARGV[$i+1];					
				}
				
			elsif($ARGV[$i]=~/-user_side_to_trim/)
				{
					$user_side_to_trim=$ARGV[$i+1];					
				}
				
			#elsif($ARGV[$i]=~/-user_no_of_bases_to_trim/)
			#	{
			#		$user_no_of_bases_to_trim=$ARGV[$i+1];					
			#	}
				
			elsif($ARGV[$i]=~/-increase_repeat_length/)
				{
					$increase_repeat_length=$ARGV[$i+1];					
				}
			
			elsif($ARGV[$i]=~/-repeat_extension_identity/)
				{
					$repeat_extension_identity=$ARGV[$i+1];					
				}	
				
			elsif($ARGV[$i]=~/-user_side_to_increase_length/)
				{
					$user_side_to_increase_length=$ARGV[$i+1];					
				}
				
			elsif($ARGV[$i]=~/-user_no_of_bases_to_increase_length/)
				{
					$user_no_of_bases_to_increase_length=$ARGV[$i+1];					
				}
				
				
			#elsif($ARGV[$i]=~/-check_consensus/)
			#	{
			#		$check_consensus=$ARGV[$i+1];					
			#	}
							
			#elsif($ARGV[$i]=~/-find_alternate_repeat/)
			#	{
			#		$find_alternate_repeat=$ARGV[$i+1];					
			#	}
							
			elsif($ARGV[$i]=~/-check_direction/)
				{
					$check_direction=$ARGV[$i+1];					
				}
			#elsif($ARGV[$i]=~/-ref_lib_file/)
			#	{
			#		$ref_lib_file=$ARGV[$i+1];	
			#		$ref_lib_file="$tmp_dir\/$ref_lib_file";				
			#	}	




			elsif($ARGV[$i]=~/-shorten_array/)
				{
					$shorten_array=$ARGV[$i+1];					
				}	
				
			elsif($ARGV[$i]=~/-sa_allowed_percent_similarity/)
				{
					$sa_allowed_percent_similarity=$ARGV[$i+1];					
				}				
					
			elsif($ARGV[$i]=~/-user_side_to_shorten/)
				{
					$user_side_to_shorten=$ARGV[$i+1];					
				}
			elsif($ARGV[$i]=~/-array_quality_score_cutoff/)
				{
					$array_quality_score_cutoff=$ARGV[$i+1];					
				}	
	
		elsif($ARGV[$i]=~/-h/ or $ARGV[$i]=~/-help/)
			{
				#----- CRISPRDetect help ---------------------------------------------------
				&show_help($clustalw_found,$water_found,$seqret_found,$RNAfold_found,$cd_hit_found,$blastn_found);
				
				exit;
			}	
	}
	
	


if($output_file_specified==0)
	{
		print "\nWrong input. A output filename should be specified [e.g. -o output.txt]\n\n";
		exit;
	}



############################################# Auto-estimation of cutoff score #########################################

my $skip_auto_estimation_of_score_cutoff=0;
if($skip_auto_estimation_of_score_cutoff==0)
	{
		if($all_gene_positions_file eq "NA" and $annotate_cas_genes==0) #--- as no Cas predictions are available; use a lower score cutoff
			{
				if($array_quality_score_cutoff ==4)
					{
						$array_quality_score_cutoff=3;
					}
			}
		if($check_direction==0) #--- as reference repeat matching is not available; use a lower score cutoff
			{
				if($array_quality_score_cutoff ==4)
					{
						$array_quality_score_cutoff=3;
					}
			}
		if($#arr_sequence_files >1000 and ($all_gene_positions_file eq "NA" or $check_direction==0)) #--- as its likely metagenomic reads/contigs; use a lower score cutoff
			{
				if($array_quality_score_cutoff ==4)
					{
						$array_quality_score_cutoff=3;
					}
			}	
	}
######################################################################################################################

#------ step 0: check if Cas gene annotation is set or not ----
our %hash_of_accession_and_all_gene_start_stop;
my $predicted_cas_gene_position_and_sequences="NA";



#--- define the files already generated --


if($annotate_cas_genes==1 and $all_gene_positions_file eq "NA")
	{
		#--- check if GeneMarkS is present or not --------------------
		my $gmhmmp_found=`gmhmmp.pl >&1 2>&1`; chomp $gmhmmp_found; $gmhmmp_found=~s/\r//;
		
		if($gmhmmp_found =~ /command not found/ )
			{
				print "\nError: The GeneMarkS package (i.e. gmhmmp.pl) is not found in PATH. Please install GeneMarkS and make sure gmhmmp.pl is available in PATH or do not use this option.\n"; exit;
			}
			
		#if(not -e "$cd_path/GeneMarkS/gmhmmp.pl" ){print "\nError: The GeneMark is not found in $cd_path\n"; exit;}
		
		#--- check if hmmsearch is present or not --------------------
		my $ret=`hmmsearch -h | grep -F 'http' >&1`; chomp $ret; $ret=~s/\r//;
		if($ret =~ /No such file/ ){print "\nError: The hmmsearch is not found in path\n"; exit;}
		
		#--- copy all the *.mod files from /APPS/GeneMarkS/ to tmp_dir
		#system("cp /APPS/GeneMarkS/*.mod $tmp_dir/.");
		#system("cp $cd_path/HMMER_FILES/all_cas_profiles.hmm* $tmp_dir/.");
		#system("cp $cd_path/HMMER_FILES/makarova_summary_table_of_cas_genes.tab $tmp_dir/.");
		
		
		#---- now do the annotation, predict cas gene and generate all_gene_positions_file
		
		if($all_gene_positions_file eq "NA")
			{
				$all_gene_positions_file=&get_unique_id()."_CDS_positions.txt";							
				system("touch $tmp_dir/$all_gene_positions_file");
			}
		if($predicted_cas_gene_position_and_sequences eq "NA")
			{
				$predicted_cas_gene_position_and_sequences=&get_unique_id()."_predicted_cas_gene_position_and_sequences.txt";							
				system("touch $tmp_dir/$predicted_cas_gene_position_and_sequences");
			}
		#---	
		my $uniqueID=&get_unique_id();		
		
		my $tmp_seq_file="$tmp_dir/TEMP_".$uniqueID."_seq.fa";
		open(WR,">$tmp_seq_file");
		foreach my $accession(keys %hash_of_seq_id_and_seq)
			{
				#--- write the sequences to the tmp_seq				
				print WR ">$accession\n$hash_of_seq_id_and_seq{$accession}\n";
			}	
		close(WR);	
		
		
		
		#--- create the sequence file in tmp_dir --
		
		#print "\n\t\tProcessing $tmp_seq_file for annotation, Cas prediction and table generation ..\n";
		
		system("perl $cd_path/script_find_cas_genes.pl -script_dir $cd_path -tmp $tmp_dir -i $tmp_seq_file -o $all_gene_positions_file -s $predicted_cas_gene_position_and_sequences -T $no_of_threads");
			
			
		#print "\t\tCheck: $tmp_dir/$all_gene_positions_file \n";
		#print "\t\tCheck: $tmp_dir/$predicted_cas_gene_position_and_sequences \n";
		
		#---- load the unknown GeneMarkS predicted gene start and stop positions from .GFF file
		my $genemarks_gff_file="$tmp_seq_file.GFF";
		#print "\n\n\t\$genemarks_gff_file= $genemarks_gff_file\n";
		my @arr_genemark_rows=`grep -v '^#' $genemarks_gff_file >&1`;
		foreach my $row(@arr_genemark_rows)
			{
				chomp $row; $row=~s/\r//;
				if($row=~/\t/)
					{
						my @arr_r1=split('\t',$row); #SEQUENCE_01487775247XMLRUNNMHDRISVGAAC15510COMPLETEGENOME       GeneMark.hmm    CDS     717     1124    15.588505       -       0       gene_id=1
						my $accession=$arr_r1[0];
						my $start=$arr_r1[3];
						my $stop=$arr_r1[4];
						
						$hash_of_accession_and_all_gene_start_stop{$accession}{$start}=$stop;
					}
			}	
		
	}


#------


#----- now create 2 files to replace temp seqIDs with original seqIDs in $all_gene_positions_file and $predicted_cas_gene_position_and_sequences---

my $predicted_cas_gene_table=$output_file.".CAS_GENE.tab";
my $predicted_cas_gene_domain_table=$output_file.".CAS_DOMAIN.tab";
my %hash_of_accession_with_cas_gene_or_domains;

if($all_gene_positions_file and $all_gene_positions_file ne "NA")
	{
		my @arr_all_gene_positions_file=`less $tmp_dir/$all_gene_positions_file >&1`;

		open(WR,">$predicted_cas_gene_table");
		foreach my $row(@arr_all_gene_positions_file)
			{
				chomp $row; $row=~s/\r//;
				my @arr_r1=split('\t',$row);
				my $accession=$arr_r1[0];
				my $start=$arr_r1[1];
				my $stop=$arr_r1[2];
				
				my $original_seqID=$hash_id_lookup_table{$accession};
				
				if($hash_id_lookup_table{$accession})
					{
						$arr_r1[0]=$hash_id_lookup_table{$accession};
					}
				my $new_row=join("\t",@arr_r1);	
				print WR "$new_row\n";
				
				#------ also store the accesion --
				$hash_of_accession_with_cas_gene_or_domains{$accession}=1;
				$hash_of_accession_and_all_gene_start_stop{$accession}{$start}=$stop;
				
			}
		close(WR);
	}

if($predicted_cas_gene_position_and_sequences and $predicted_cas_gene_position_and_sequences ne "NA")
	{
		my @arr_all_domain_positions_file=`less $tmp_dir/$predicted_cas_gene_position_and_sequences >&1`;
		open(WR,">$predicted_cas_gene_domain_table");
		foreach my $row(@arr_all_domain_positions_file)
			{
				chomp $row; $row=~s/\r//;
				my @arr_r1=split('\t',$row);
				my $accession=$arr_r1[0];
				my $original_seqID=$hash_id_lookup_table{$accession};
				
				if($hash_id_lookup_table{$accession})
					{
						$arr_r1[0]=$hash_id_lookup_table{$accession};
					}
				my $new_row=join("\t",@arr_r1);	
				print WR "$new_row\n";
			}
		close(WR);
	}
#print "\t\tThe original seqIDs are in this files: $predicted_cas_gene_table \n\t and $predicted_cas_gene_domain_table \n\n";

#----- now create short contig IDs to be used in "# Identified Cas genes:" field
our %hash_of_accession_and_short_contigIDs; 
my $short_contig_index=1;
foreach my $accession(sort keys %hash_of_accession_with_cas_gene_or_domains)
	{
		my $short_contigID="C$short_contig_index";
		$hash_of_accession_and_short_contigIDs{$accession}=$short_contigID;
		$short_contig_index++;
	}
#------------------------------------------
our $short_contig_id_legends=" ";
if($all_gene_positions_file ne "NA" and $wgs!=0)
	{
		$short_contig_id_legends="# Short ContigIDs used in Cas gene position : ";
		
		foreach my $acc(sort{$hash_of_accession_and_short_contigIDs{$a} cmp $hash_of_accession_and_short_contigIDs{$b}} keys %hash_of_accession_and_short_contigIDs)
			{
				my $s_cid=$hash_of_accession_and_short_contigIDs{$acc};
				my $original_seqID=$hash_id_lookup_table{$acc};
						
				$short_contig_id_legends=$short_contig_id_legends."$s_cid: $original_seqID; ";
			}
		$short_contig_id_legends=~s/; $//;					
	}

#print "\n\$short_contig_id_legends= $short_contig_id_legends\n";
#exit;

#----- step 1: predict CRISPR hotspots ---------------------



my $date_n_time=localtime(time);
my $file_index=0;
my $combined_hotspots_file=$idnumber."_combined_hotspots.txt";
system("touch $tmp_dir\/$combined_hotspots_file");

#system("echo '# Thank you for using CRISPRDetect' >$tmp_dir\/$combined_hotspots_file"); 
#system("echo '# Author: Ambarish Biswas' >$tmp_dir\/$combined_hotspots_file"); 
#system("echo '# $date_n_time' >$tmp_dir\/$combined_hotspots_file");
#system("echo '' >$tmp_dir\/$combined_hotspots_file");
#system("echo '' >$tmp_dir\/$combined_hotspots_file");
system("chmod 777 $tmp_dir\/$combined_hotspots_file");



my $remaining_sequences=$#arr_sequence_files+1;

#print "$tmp_dir\/$combined_hotspots_file\n\n";


my $wgs_or_metagenomic_contigs=0;
my %hash_of_seqID_with_crispr_hotspots;
if($#arr_sequence_files+1 >100 and $no_of_threads >1 and $#arr_sequence_files+1 > $no_of_threads*2)
	{
		
		if($quiet !=1)
			{
				print "\tChecking $remaining_sequences sequences for CRISPR like sequence repeats.\n";
			}
		
		$wgs_or_metagenomic_contigs=1;
		my $minimum_seq_length=100;
		my($nof_identified_ids)=&identify_read_or_contigIDs_with_crispr_hotspots($pm,$no_of_threads,$minimum_seq_length,$minimum_repeat_length,$remaining_sequences,\%hash_of_seqID_with_crispr_hotspots);
		
		$remaining_sequences=$nof_identified_ids;
		
		if($quiet !=1)
			{
				print "\tTotal $nof_identified_ids sequences identified to have CRISPR like sequence repeats.\n";
			}
	}


foreach my $seq_id(keys %hash_of_seq_id_and_seq)
	{			
			#print "$seq_id\n";
			
			#--------- check if metagenomic sequence was inputted and the current seq_id identified to have CRISPRs like repeat-----
			if($wgs_or_metagenomic_contigs==1)
				{
					if(not $hash_of_seqID_with_crispr_hotspots{$seq_id}){next;}
				}				
			#----------
			$remaining_sequences--;
			
			if($quiet !=1 and $remaining_sequences >1000)
				{
					my $remainder=$remaining_sequences % 1000;
					if($remainder == 0)
						{
							$pm->start and next;
							
							if(-e "$tmp_dir\/$combined_hotspots_file")
								{
									my $hotspots_identified=`grep '>' $tmp_dir\/$combined_hotspots_file | wc -l >&1`;
									$hotspots_identified=int($hotspots_identified);
									
									if($hotspots_identified>0)
										{							
											print "\r$hotspots_identified putative CRISPRs identified [Remaining sequences to be checked: $remaining_sequences]              \t";									
										}					
								}
							$pm->finish;	
						}
				}
			#------ check if the sequence already been processed b4, if continue is set
			if(-e "$tmp_dir\/$continue_from_last_process_file" and $continue_from_last_process==1)
				{
					#print "grep -w '$seq_file' tmp/$continue_from_last_process_file\n";
					my $is_already_processed=`grep -F -w '$seq_id' $tmp_dir\/$continue_from_last_process_file >&1`;
					if($is_already_processed=~/$seq_id/)
						{
							print "$seq_id already processed. Continuing..\n";
							next;
						}	
				}	
			
					#print "$seq_file\n";
			#select(undef, undef, undef, 0.01); #--- will sleep for 1/4 seconds
			$pm->start and next;
			
			#$seq_file=$seq_file."\.fna";
			my $seq=$hash_of_seq_id_and_seq{$seq_id};
			
			#&predict_crispr_hotspots($seq_file,$combined_hotspots_file);	
			my $accession=$seq_id;
			my ($total_hotspots,$potential_crisprs)=&get_crisprdetect_hotspots($quiet,$accession,$word_length,$minimum_word_repeatation,$minimum_spacer_gap,$maximum_spacer_gap,$combined_hotspots_file,\%hash_id_lookup_table);	
			
			#print "Total $potential_crisprs potential CRISPR hotspots identified out of $total_hotspots hotspots\n";
			
			$pm->finish;
	}
	
	$pm->wait_all_children;

if($quiet !=1 )
	{
		print "\n\tPutative CRISPRs prediction done.\n";
	}	
	
	
#print "$tmp_dir\/$combined_hotspots_file\n\n";	
#exit;








#----- step 3: Process the CRISPR arrays to get the longest one and load up %hash_of_all_crispr_hotspots -----------
#print "\nGoing to load up the CRISPR hotspots ...";
my %hash_of_all_crispr_hotspots;
&load_crispr_hotspots("$tmp_dir\/$combined_hotspots_file",\%hash_of_all_crispr_hotspots);


unlink("$tmp_dir\/$combined_hotspots_file");
#print ".. Done.\n\n";	
#-------------------------------------------------------------------------------------------------------------------







#exit;		
		
	

				

############################################################################################ process the putative CRISPRs
#------- create sequence files and also get the total CRISPR hotspots to be processed
my $mode="multiFASTA";

my $nof_seq_to_be_processed=0;
my $total_hotspots=0;
foreach my $accession(sort keys %hash_of_all_crispr_hotspots)
	{
		#--- write the sequences to the tmp_dir so that down stream analysis can be performed ---
		
		#print "$accession\n";
		#open(WR,">$tmp_dir\/$accession\.fna");
		#print WR ">$accession|\n$hash_of_seq_id_and_seq{$accession}\n";
		#close(WR);
		
		$nof_seq_to_be_processed++;
		
		#---
		foreach my $range(sort keys %{$hash_of_all_crispr_hotspots{$accession}})
			{
				#print "$accession-$range\n";
				$total_hotspots++;
			}	
	}
	
#--- set the mode accordingly by checking the no. of hotspots Vs. no. of sequences to be processed--
my $average_hotspots_per_sequence=1;
if($total_hotspots >0 and $nof_seq_to_be_processed >0)
	{
		$average_hotspots_per_sequence=int($total_hotspots/$nof_seq_to_be_processed);
		
		#print "\$average_hotspots_per_sequence= $average_hotspots_per_sequence\n";
	}
if($nof_seq_to_be_processed==1)
	{
		$mode="FASTA";
	}
elsif($nof_seq_to_be_processed < 5 and $average_hotspots_per_sequence >5)
	{
		$mode="FASTA";
	}
		
#-------------------------------



if($quiet !=1)
	{
		print "\tTotal putative CRISPRs to process: $total_hotspots from $nof_seq_to_be_processed sequences\n";
	}
	
my $sequences_processed=0;
my $remaining_sequences_to_be_processed;#=$nof_seq_to_be_processed;	

my $remaining_hotspots=$total_hotspots;	



my $skip_process_management=1;
my $process_list_file_of_accession_and_range=$tmp_dir."/process_list_file_of_accession_and_range_".&get_unique_id().".txt";
system("touch $process_list_file_of_accession_and_range");

foreach my $accession(sort keys %hash_of_all_crispr_hotspots)
	{	
	
		$sequences_processed++;
		#------ check if the sequence already been processed b4, if continue is set -----------------------------
		if(-e "$tmp_dir\/$continue_from_last_process_file" and $continue_from_last_process==1)
			{
				#print "grep -w '$accession' $tmp_dir\/$continue_from_last_process_file\n";
				my $is_already_processed=`grep -F -w '$accession' $tmp_dir\/$continue_from_last_process_file >&1`;
				if($is_already_processed=~/$accession/)
					{
						next;
					}
			}
		
		#---------- create a temp file, and start writting the arrays in tab delimited order ----- 
		 my $tmp_output_file=$accession.&get_unique_id()."temp_output.txt";
		 open(WR1,">$tmp_dir\/$tmp_output_file") or print "$!";close(WR1);system("chmod 777 $tmp_dir\/$tmp_output_file");
		#---------------------------------------------------------------------------------------------------------- 
		
		
		# if(not -e "$tmp_dir\/$accession\.fna")
		#	{
		#		print "\tNot found \$accession=$accession\n";
		#		next;
		#	}
		#---------------------------------------------------------------------------------------------------------

	 

		if($mode eq "multiFASTA")
			{
				#--- if not quiet=true, show how many sequences remaining
				$remaining_sequences_to_be_processed=$nof_seq_to_be_processed -$sequences_processed;
				
				if($quiet !=1)
					{
						if($hash_id_lookup_table{$accession})
							{
								print "\tProcessing: $hash_id_lookup_table{$accession} \t Remaining: $remaining_sequences_to_be_processed\n";
							}
						else{
								print "\t$accession\t Remaining: $remaining_sequences_to_be_processed\n";
							}	
					}	
				
				
				select(undef, undef, undef, 0.05); #--- will sleep for 1/4 seconds
				$pm->start and next; # do the fork 
			}

	 
	 


		#$accession.time().".gff"; 
		 
		#print "Current accession=$accession \tRemaining: $total_hotspots\n\n<br>";	#next;
		#if($accession!~/NC_000913/){exit 0; next;}
		
		my %hash_of_arrays_per_accession;
		my %hash_of_original_arrays_per_accession;
		#my %hash_of_questionable_arrays_per_accession;
		my %hash_of_currently_running_ranges;
		#-------------------------------------------------------------------
			
		my $crispr_index=1;
		my $processed_hotspots=0;
	
		foreach my $range( keys %{$hash_of_all_crispr_hotspots{$accession}})
		  {		 
			my $not_a_crispr=0;  
			
			my($range_start,$range_stop)=split("-",$range);	
			
			

			
			
			
			#-----------------
			if($mode eq "FASTA")
				{
					$remaining_hotspots--;
					
					#--- check if any other putative CRISPR is being processed that overlaps with the current range
					
					if($skip_process_management==0)
					{
					my $putative_crispr_is_definitely_not_a_crispr=0;
					my $overlapping_putative_crispr_being_processed=1;
					while($overlapping_putative_crispr_being_processed >0)
						{
							my $found=0;
							#--- get all the ranges from $process_list_file_of_accession_and_range --
							my @arr_running_acc_and_ranges=`grep -F -w '$accession' $process_list_file_of_accession_and_range >&1`;
							
							if(defined $arr_running_acc_and_ranges[0] and $arr_running_acc_and_ranges[0]=~/\S+/)
								{
									foreach my $rec(@arr_running_acc_and_ranges)
										{
											chomp $rec; $rec=~s/\r//; my $arr_r1=split('\t',$rec);
											my @arr_r1=split('\t',$rec);  #$accession	$range	1|0
											my $running_range=$arr_r1[1];
											my $status=$arr_r1[2];
											

											
											my($running_range_start,$running_range_stop)=split("-",$range);
											
											if($status==1)
												{
													if($range_start >= $running_range_start and $range_start <= $running_range_stop) # i.e. running process
														{
															$found=1;
														}
													if($range_stop >= $running_range_start and $range_stop <= $running_range_stop) # i.e. running process
														{
															$found=1;
														}
												}									
											elsif($status == -1)
												{
													#---- if the status is -1, then the region are likely to be a tandem repeat: so skip all subsequent processing of putative CRISPRs belong to this region 
													$putative_crispr_is_definitely_not_a_crispr=1;
													last;
												}
											elsif($status==0)
												{
													#--- this means, although the process is finished; a re-run might improve the scoring of the predicted CRISPR ---
												}	
										}
								}				
								
							
							#----- all subsequent runs will be stopped ---------------------------------
							if($putative_crispr_is_definitely_not_a_crispr==1){last;}
							#---------------------------------------------------------------------------
								
								
							if($found >0)
								{
									select(undef, undef, undef, 0.20); #--- will sleep for 1/4 seconds	
								}
							else{
									######################### store the range to the process_list_file_of_accession_and_range file to prevent other processors to simulteniously process putative CRISPR belongs to same range ##
									open(APP,">>$process_list_file_of_accession_and_range");
									flock(APP,2);
									print APP "$accession\t$range\t1\n";
									close(APP);
									##################################################################################################################################################################	
								}		
							$overlapping_putative_crispr_being_processed=$found;	
						}
					
					}
					
					
					
					
					if($quiet !=1)
						{
							if($hash_id_lookup_table{$accession})
								{
									print "\t$hash_id_lookup_table{$accession} - $range\t Remaining: $remaining_hotspots\n";
								}
							else{
									print "\t$accession\t - $range\t Remaining: $remaining_hotspots\n";
								}	
						}	
					#---------------				
					
					select(undef, undef, undef, 0.05); #--- will sleep for 1/4 seconds		 
					$pm->start and next; # do the fork 
				}
			 

			
			#------------------------- store the whole array in @current_array after fixing the coords  ---------------------------------------------------------------------------
				
			$hash_of_original_arrays_per_accession{$range_start}{$range_stop}=$hash_of_all_crispr_hotspots{$accession}{$range};
			
			
			
			
			
			
			
			
			
			#----- check if the $range_start already found within another array --------------------------------------
			

			#------ --------------------------------------------------------------------------------------------------
			my ($crispr_hotspot_already_exist,$existing_q_score)=&check_array_existance($array_quality_score_cutoff,$range_start,$range_stop,$tmp_output_file);		
			
			
		
			
			if($crispr_hotspot_already_exist==1)
				{
					if($quiet !=1)
						{
							#print "\t\tAlready part of previously processed CRISPR. $range Skipping...\n";
						}	
					
					if($mode eq "FASTA")
						{
							if($skip_process_management==0)
								{
									&update_process_list_file_of_accession_and_range($process_list_file_of_accession_and_range,$accession,$range,'0');
								}	
							$pm->finish; 
						}
				}
			
			

			
			my @original_array=split('\n',$hash_of_all_crispr_hotspots{$accession}{$range});
			
			#-------------- get the model repeat ---------------------------------------------------------	
			my $model_repeat;	
			my $last_line=$original_array[$#original_array];$last_line=~s/\s+/\t/g;
			my @tmp_arr_last_line=split('\t',$last_line);
			$model_repeat=$tmp_arr_last_line[$#tmp_arr_last_line];
			#---------------------------------------------------------------------------------------------

			
			
			

			

			
			#--------------------------------------------------- get @current_array ----------------------

			my @current_array; 
			my @modified_array;
			
			my($avg_spacer_length,$total_spacer_length)=&get_current_array(\@original_array,\@current_array);
			

				
			#print "\n\nInput array:\n";		
			#&print_array($model_repeat,\@current_array);
			#---------------------------------------------
			
			my $atleast_one_operation_performed=0;

			#-------------- Now apply different modules -----------------------------------
					
			for(my $pass=0;$pass<2;$pass++)
				{	
					my($array_start_pos,$array_stop_pos,$avg_spacer_len)=&find_array_start_stop_position('F',\@current_array);			
					$avg_spacer_length=$avg_spacer_len;
					
					#print "Pass: $pass $array_start_pos,$array_stop_pos,$avg_spacer_len\n";			
					undef @modified_array;
					
					#----------Special case: remove poor/degenerated repeats from either ends ------------
					
					my $no_of_repeats=$#current_array-4;
					
					if($pass==1)
						{							
							
							
							my $first_repeat_line=$current_array[4];
							my @arr_t1=split('\t',$first_repeat_line);
							my $first_repeat_seq=$arr_t1[1];
							my $tmp_frs=$first_repeat_seq;$tmp_frs=~s/\.//g;
							my %tmp_hash_frs;
							my $number_of_insertions_frs=0;
							if(defined $arr_t1[3]){ $number_of_insertions_frs=&get_number_of_insertions($arr_t1[3],\%tmp_hash_frs);}
							my $first_repeat_degeneracy_score=length($tmp_frs)+$number_of_insertions_frs;
							
							
							
							my $last_repeat_line=$current_array[$#current_array-1];
							my @arr_t2=split('\t',$last_repeat_line);
							my $last_repeat_seq=$arr_t2[1];
							my $tmp_lrs=$last_repeat_seq;$tmp_lrs=~s/\.//g;
							my %tmp_hash_lrs;
							my $number_of_insertions_lrs=0;
							if(defined $arr_t2[3]){$number_of_insertions_lrs=&get_number_of_insertions($arr_t2[3],\%tmp_hash_lrs);}
							my $last_repeat_degeneracy_score=length($tmp_lrs)+$number_of_insertions_lrs;
							
							#print "\$no_of_repeats=$no_of_repeats\t \$first_repeat_seq=$first_repeat_seq\t \$last_repeat_seq=$last_repeat_seq\n";
							
							my @side_to_shorten_first;
							if($no_of_repeats>3 and $first_repeat_degeneracy_score!=$last_repeat_degeneracy_score and ($first_repeat_degeneracy_score>0 or $last_repeat_degeneracy_score>0))
								{
									if($first_repeat_degeneracy_score>=$last_repeat_degeneracy_score )
										{
											push(@side_to_shorten_first,"TOP-1,");
											#push(@side_to_shorten_first,"BOTTOM-1,");
											push(@side_to_shorten_first,"NA,");
										}
									else{
											push(@side_to_shorten_first,"BOTTOM-1,");
											#push(@side_to_shorten_first,"TOP-1,");
											push(@side_to_shorten_first,"NA,");
										}	
								
								
							

							if($shorten_array==1)
									{
											
											foreach my $tmp_user_side_to_shorten(@side_to_shorten_first)
												{
											
													my $case_found=0;	
													my $tmp_minimum_no_of_repeats=1;
													my $tmp_sa_allowed_percent_similarity=90;							

													#------ finally remove the rest degenerated repeats		
													#$tmp_user_side_to_shorten="BOTTOM-1,";
													($case_found)=&shorten_array($range,$tmp_minimum_no_of_repeats,$tmp_sa_allowed_percent_similarity,$tmp_user_side_to_shorten,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											
													if($case_found==1)
														{
															for(my $m=3;$m>=0;$m--)
																{
																	unshift(@modified_array,$current_array[$m]);
																	#shift(@modified_array);
																}
															push(@modified_array,$current_array[$#current_array]);	
															
															@current_array=@modified_array;
															$atleast_one_operation_performed++;
														}
													
													
													undef @modified_array;
												}	

									}
									
							if($remove_insertion_from_repeat==1 and $model_repeat=~/-/)
									{									
										my $case_found=0;
										($model_repeat,$case_found)=&fix_arrays_with_insertion_in_repeat($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											
											
										if($case_found==1)
											{
												$atleast_one_operation_performed++;
											}
										undef @modified_array;	
									}
									
									
							if($check_consensus==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
									{
											#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
											
											my $case_found=0;	
											($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											
											
											if($case_found==1)
												{
													$atleast_one_operation_performed++;
												}
											undef @modified_array;				
									}
											

									#print "$pass:Array after shorten_array\n";
									#&print_array($model_repeat,\@current_array);	
								}							
						}




					#--------------------------------- this is default flow [the first two modules has the be in the order: 1. Extend repeat length, then trim repeat length]--------------------------------------------------------------------------

					#if($pass==0)
					#	{
						
							######################### [DO not change the flow and order of the first 2 modules: 1increase_repeat_length, 2: trim_repeats, 3: extend
							
							#print "A1: $pass:Before increase_repeat_length\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------			
							
							if($increase_repeat_length==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
								{
									#system("echo '$user_side_to_increase_length' >log.txt");
									my @arr_user_side_to_increase_length=split(',',$user_side_to_increase_length);
									
									foreach my $side_and_bases(@arr_user_side_to_increase_length)
										{			
									
											if($side_and_bases!~/NA/)
												{
													my($u_side_to_increase_length,$u_no_of_bases_to_increase_length)=split('-',$side_and_bases);
													#---------------------------------------------------------------
													
													my $case_found=0;	
													undef @modified_array;
													($model_repeat,$case_found)=&increase_all_repeat_lengths($range,$u_side_to_increase_length,$u_no_of_bases_to_increase_length,$accession,$model_repeat,\@current_array,\@modified_array);
													
													
													if($case_found==1)
														{
															#------------ complete the @modified array ---
															for(my $m=3;$m>=0;$m--)
																{
																	unshift(@modified_array,$current_array[$m]);
																	#shift(@modified_array);
																}
															push(@modified_array,$current_array[$#current_array]);
																
															@current_array=@modified_array;
															
															#undef @modified_array;
															$atleast_one_operation_performed++;
														}
														
													undef @modified_array;	
												}	
										
											else{							#----- auto check with $repeat_extension_identity
											
													#system("echo '$repeat_extension_identity' >log.txt");
													
													my $case_found1=0;	
													my $sides_to_increase_length="NA-0,";
													undef @modified_array;
													
													($sides_to_increase_length,$case_found1)=&auto_detect_repeat_sides_and_bases_to_increase($range,$repeat_extension_identity,$accession,$model_repeat,\@current_array,\@modified_array);
													
													#print "$sides_to_increase_length,$case_found1\n";
													
													if($case_found1==1)
														{
															
															my @arr_sides_to_increase_length=split(',',$sides_to_increase_length);									
															
															foreach my $side_and_bases(@arr_sides_to_increase_length)
																{			
																	#system("echo '$side_and_bases' >log.txt");
																	
																	if($side_and_bases!~/NA/)
																		{
																			my($side_to_increase_length,$no_of_bases_to_increase_length)=split('-',$side_and_bases);
																			#---------------------------------------------------------------
																			
																			my $case_found=0;	
																			#print "$range,$side_to_increase_length,$no_of_bases_to_increase_length,$accession,$model_repeat,\n";
																			($model_repeat,$case_found)=&increase_all_repeat_lengths($range,$side_to_increase_length,$no_of_bases_to_increase_length,$accession,$model_repeat,\@current_array,\@modified_array);
																			
																			
																			if($case_found==1)
																				{
																					#------------ complete the @modified array ---
																					for(my $m=3;$m>=0;$m--)
																						{
																							unshift(@modified_array,$current_array[$m]);
																							#shift(@modified_array);
																						}
																					push(@modified_array,$current_array[$#current_array]);
																						
																					@current_array=@modified_array;
																					
																					#undef @modified_array;
																					$atleast_one_operation_performed++;
																				}
																				
																			undef @modified_array;	
																		}
																}		
														}
														
													undef @modified_array;	
												}	
										
										}	
								}
							
							
							#print "A2: $pass:After increase_repeat_length\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------
							
							
							if($trim_repeats==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
								{							
									my @arr_user_sides_to_trim=split(',',$user_side_to_trim);
									
									foreach my $side_and_bases(@arr_user_sides_to_trim)
										{
											
											my $case_found=0;				
											#$minimum_repeat_length=11;
											my $trimming_cutoff2=$trimming_cutoff;
											
											if($no_of_repeats>3){$trimming_cutoff2=20;}
											
											($model_repeat,$case_found)=&trim_repeat_ends_and_improve_score($range,$minimum_repeat_length,$side_and_bases,$trimming_cutoff2,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											
											
											if($case_found==1)
												{
													$atleast_one_operation_performed++;
												}
											
											
											if($case_found==1)
												{	
													
													if($side_and_bases=~/NA/)
														{
															undef @modified_array;							
															for(my $m=3;$m>=0;$m--)
																{
																	unshift(@modified_array,$current_array[$m]);
																}
															
															my $case_found1=0;
															($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
															
															
															push(@modified_array,$current_array[$#current_array]);
																							
															
															if($case_found1==1)	{@current_array=@modified_array;}								
																		
															undef @modified_array;	
														}
												
											}
												
													
											undef @modified_array;
										}
									
								}
							
							#print "A2.1: $pass:after trim_repeats\n";
							#&print_array($model_repeat,\@current_array);
							
							#------------------------ check if after trimming the model_repeat becomes too short to be true----------------------------------
							
							if(length($model_repeat)<=$word_length)
								{
									$not_a_crispr=1; last;
								}					
							#------------------------------------------------------------
							
							if($remove_insertion_from_repeat==1 and $model_repeat=~/-/)
								{
									
									my $case_found=0;
									($model_repeat,$case_found)=&fix_arrays_with_insertion_in_repeat($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}
									
			
									undef @modified_array;	
								}
							#next;
							
						
							if($check_consensus==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
								{
									#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
									
									my $case_found=0;	
									($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}
									undef @modified_array;				
								}
								
							#---------------------------------------------------------
							#print "A5: $pass:After check_consensus \n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------
							

						
						
							
							#---------- try to extend arrays in flanks -----------------------------------					
							#print "Going to check extension\n";
							#&print_array($model_repeat,\@current_array);
							
							if($extend_array==1 and length($model_repeat)>=$word_length)    #----- remember; don't use ea_dynamic search at the first extension
								{
									
									my $case_found=0;	
									#--- for the first extension dont use ea_dynamic_search
									my $tmp_ea_dynamic_search=0;		
									($case_found)=&extend_array($range,$max_gap_between_crisprs,$tmp_ea_dynamic_search,$ea_allowed_percent_similarity,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}
									
									if($case_found==1)
										{
											for(my $m=3;$m>=0;$m--)
												{
													unshift(@modified_array,$current_array[$m]);
													#shift(@modified_array);
												}
											push(@modified_array,$current_array[$#current_array]);	
													
											@current_array=@modified_array;
											undef @modified_array;
											
											
											#------- fix the gaps ---------------------------------
											for(my $m=3;$m>=0;$m--)
												{
													unshift(@modified_array,$current_array[$m]);
												}
											
											my $case_found1=0;
											($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											
										
											if($case_found1==1)
												{
													push(@modified_array,$current_array[$#current_array]);
													@current_array=@modified_array;	
													$atleast_one_operation_performed++;
												}
														
											undef @modified_array;	
											
										}
									
									
									undef @modified_array;
								}
							

							#print "A7: $pass:After extend_array\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------	

							if($remove_insertion_from_repeat==1 and $model_repeat=~/-/)
								{

									
									my $case_found=0;
									($model_repeat,$case_found)=&fix_arrays_with_insertion_in_repeat($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}
									
			
									undef @modified_array;	
								}
							#next;
							
						
							if($check_consensus==10)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
								{
									#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
									
									my $case_found=0;	
									($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}
									undef @modified_array;				
								}
							
						
							#print "A8: $pass:After check_consensus\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------				
							

							if(($#current_array-4)>3)
								{												
									if($trim_repeats==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
										{									
											my @arr_user_sides_to_trim=split(',',$user_side_to_trim);
											
											foreach my $side_and_bases(@arr_user_sides_to_trim)
												{
													
													my $case_found=0;				
													#$minimum_repeat_length=11;
													($model_repeat,$case_found)=&trim_repeat_ends_and_improve_score($range,$minimum_repeat_length,$side_and_bases,$trimming_cutoff,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
													
													#print "\t$model_repeat,$case_found\n";
													if($case_found==1)
														{
															$atleast_one_operation_performed++;
														}
													
													
													if($case_found==1)
														{	
															
															if($side_and_bases=~/NA/)
																{
																	undef @modified_array;							
																	for(my $m=3;$m>=0;$m--)
																		{
																			unshift(@modified_array,$current_array[$m]);
																		}
																	
																	my $case_found1=0;
																	($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
																	
																	
																	push(@modified_array,$current_array[$#current_array]);
																									
																	
																	if($case_found1==1)	{@current_array=@modified_array;}								
																				
																	undef @modified_array;	
																}

													}
														
															
													undef @modified_array;
												}									
										}	
										
									#print "A8.1: $pass:After ($#current_array-4)>3\t trim_repeats\n";
									#&print_array($model_repeat,\@current_array);
									#----------------------------------------------------------		
									
									#------------------------------------------------------------
									
									if($remove_insertion_from_repeat==1 and $model_repeat=~/-/)
										{

											
											my $case_found=0;
											($model_repeat,$case_found)=&fix_arrays_with_insertion_in_repeat($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											
											
											if($case_found==1)
												{
													$atleast_one_operation_performed++;
												}
											

											undef @modified_array;	
										}
									
									
									if($check_consensus==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
										{
											#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
											
											my $case_found=0;	
											($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											
											
											if($case_found==1)
												{
													$atleast_one_operation_performed++;
												}
											undef @modified_array;				
										}
					
								}			

							#print "A9: $pass:After ($#current_array-4)>3\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------	
							
							#---------- then remove poor/degenerated repeats from either ends ------------

							if($shorten_array==1)
								{
									

									my $case_found=0;	
									#my $tmp_minimum_no_of_repeats=2;
									#my $tmp_sa_allowed_percent_similarity=80;		
									($case_found)=&shorten_array($range,$minimum_no_of_repeats,$sa_allowed_percent_similarity,$user_side_to_shorten,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									

									
									if($case_found==1)
										{
											for(my $m=3;$m>=0;$m--)
												{
													unshift(@modified_array,$current_array[$m]);
													#shift(@modified_array);
												}
											push(@modified_array,$current_array[$#current_array]);	
											
											

											
											@current_array=@modified_array;
											$atleast_one_operation_performed++;
										}
									
									
									undef @modified_array;
								}

							#print "A10: $pass:After shorten_array\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------						
							
							if($remove_insertion_from_repeat==1 and $model_repeat=~/-/)
								{							
									my $case_found=0;
									($model_repeat,$case_found)=&fix_arrays_with_insertion_in_repeat($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}
									
			
									undef @modified_array;	
								}
							
							#print "$pass:After remove_insertion_from_repeat\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------		
							
							if($check_consensus==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
								{
									#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
									
									my $case_found=0;	
									($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}
									undef @modified_array;				
								}
									

							#print "A11: $pass:After check_consensus\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------					


							
							if($trim_repeats==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
								{
									
									
									my @arr_user_sides_to_trim=split(',',$user_side_to_trim);
									
									foreach my $side_and_bases(@arr_user_sides_to_trim)
										{
											
											my $case_found=0;				
											#$minimum_repeat_length=11;
											($model_repeat,$case_found)=&trim_repeat_ends_and_improve_score($range,$minimum_repeat_length,$side_and_bases,$trimming_cutoff,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											
											
											if($case_found==1)
												{
													$atleast_one_operation_performed++;
												}
											
											
											if($case_found==1)
												{	
													
													if($side_and_bases=~/NA/)
														{
															undef @modified_array;							
															for(my $m=3;$m>=0;$m--)
																{
																	unshift(@modified_array,$current_array[$m]);
																}
															
															my $case_found1=0;
															($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
															
															
															push(@modified_array,$current_array[$#current_array]);
																							
															
															if($case_found1==1)	{@current_array=@modified_array;}								
																		
															undef @modified_array;	
														}
												}
												
													
											undef @modified_array;
										}
									
								}
							
							#print "A12: $pass:After trim_repeats\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------		
							
							
							if($remove_insertion_from_repeat==1 and $model_repeat=~/-/)
								{						
									my $case_found=0;
									($model_repeat,$case_found)=&fix_arrays_with_insertion_in_repeat($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}

									undef @modified_array;	
								}
							
							
							if($check_consensus==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
								{
									#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
									
									my $case_found=0;	
									($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
									
									
									if($case_found==1)
										{
											$atleast_one_operation_performed++;
										}
									undef @modified_array;				
								}
							
							#print "A13: $pass:After trim_repeats\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------				
					#	}
				



							#print "\n\n\nAAAAAAAAA:::::: $pass:Array after pass:$pass\n";
							#&print_array($model_repeat,\@current_array);
							#----------------------------------------------------------	


							########################### if the median spacer length become shorter than 5, give up ############################	
							
							my $median_spacer_length=&get_median_spacer_length(\@current_array);	
							
							
							if($median_spacer_length<5)
								{									
									$not_a_crispr=1;
									#$pm->finish;							
									#last;						
								}
							################################################################################################################

			} #------- end of pass		
				
				

			#----- skip to next record, if $model_repeat_length <15

				###################################################################################################################
				#----------------------------------------- post processing modules -----------------------------------------------#
				###################################################################################################################		
				
				
				
			my $median_spacer_length=&get_median_spacer_length(\@current_array);
			#print "\$median_spacer_length=$median_spacer_length\n";
			
			if($not_a_crispr==0 and length($model_repeat)>$repeat_length_cutoff and $median_spacer_length >17)
				{		
					#print "Before extend_array\n";
					#&print_array($model_repeat,\@current_array);
					#----------------------------------------------------------		
					
					#my $no_of_repeats_in_array=$#current_array-4;
					#print "$#current_array-4\n";
					#---------- try to extend arrays in flanks -----------------------------------
							
							
					if($extend_array==1 and ($#current_array-4) < 4 and length($model_repeat)>=$word_length)
						{
										
										my $case_found=0;	
												
										($case_found)=&extend_array($range,$max_gap_between_crisprs,$ea_dynamic_search,$ea_allowed_percent_similarity,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
										
										
										if($case_found==1)
											{
												$atleast_one_operation_performed++;
											}
										
										if($case_found==1)
											{
												for(my $m=3;$m>=0;$m--)
													{
														unshift(@modified_array,$current_array[$m]);
														#shift(@modified_array);
													}
												push(@modified_array,$current_array[$#current_array]);	
														
												@current_array=@modified_array;
												undef @modified_array;
												
												
												#------- fix the gaps ---------------------------------
												for(my $m=3;$m>=0;$m--)
													{
														unshift(@modified_array,$current_array[$m]);
													}
												
												my $case_found1=0;
												($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
												
											
												if($case_found1==1)
													{
														push(@modified_array,$current_array[$#current_array]);
														@current_array=@modified_array;	
														$atleast_one_operation_performed++;
													}
															
												undef @modified_array;	
												
											}
										
										
										undef @modified_array;
						}
								
					#print "After extend_array\n";
					#&print_array($model_repeat,\@current_array);
				
					if($check_consensus==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
						{
							#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
							
							my $case_found=0;	
							($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
							
							
							if($case_found==1)
								{
									$atleast_one_operation_performed++;
								}
							undef @modified_array;				
						}
				
				
					#print "Before search_unidentified_repeat_in_spacer_sequence\n";
					#&print_array($model_repeat,\@current_array);
					#----------------------------------------------------------	
							
						#print "Going to check search_unidentified_repeat_in_spacer_sequence\n";		
					if($search_unidentified_repeat_in_spacer_sequence==1)
						{
							
							my($array_start_pos,$array_stop_pos,$avg_spacer_len)=&find_array_start_stop_position('F',\@current_array);			
							$avg_spacer_length=$avg_spacer_len;
							#print "$array_start_pos,$array_stop_pos,$avg_spacer_len\n\n";
							
							for(my $m=3;$m>=0;$m--)
								{
									unshift(@modified_array,$current_array[$m]);
								}
							my $case_found=0;
							#my $allowed_percent_similarity=60;				
							($case_found)=&search_unidentified_repeat_in_spacers($range,$su_dynamic_search,$allowed_percent_similarity,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);				
							
							push(@modified_array,$current_array[$#current_array]);
							
							
							
							if($case_found==1)
								{
									$atleast_one_operation_performed++;
								}
								
							if($case_found==1)
								{
									@current_array=@modified_array;
								}
							
							
							undef @modified_array;
						}
						
					#print "After search_unidentified_repeat_in_spacer_sequence\n";
					#&print_array($model_repeat,\@current_array);
				
				


				

				if($fix_gaps_in_repeats==1)   # this will be called repeat_end_correction module
					{
						
						
						my $case_found=0;
						($case_found)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
						
							
						
						if($case_found==1)
							{
								for(my $m=3;$m>=0;$m--)
									{
										unshift(@modified_array,$current_array[$m]);
									}
								
								push(@modified_array,$current_array[$#current_array]);
								@current_array=@modified_array;	
								$atleast_one_operation_performed++;
							}
									
						undef @modified_array;	
							
					}		




				if($remove_insertion_from_repeat==1 and $model_repeat=~/-/)
					{

						
						my $case_found=0;
						($model_repeat,$case_found)=&fix_arrays_with_insertion_in_repeat($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
						
						
						if($case_found==1)
							{
								$atleast_one_operation_performed++;
							}				

						if($case_found==1)
							{

							}	
						undef @modified_array;	
					}
				#next;
				
				if($check_consensus==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
					{
						#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
						
						my $case_found=0;	
						($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
						
						
						if($case_found==1)
							{
								$atleast_one_operation_performed++;
							}
						undef @modified_array;				
					}



				########################################## special cases: $repeat_extension_identity set to 75 (and $alt_repeat_extension_identity=50) ####
				#print "\n1: Before increase_repeat_length:\n";		
				#&print_array($model_repeat,\@current_array);
				#----------------------------------------------------------
				
								
				if($increase_repeat_length==1 and length($model_repeat)<48)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
					{
						#system("echo '$user_side_to_increase_length' >log.txt");
						
						
						
						my @arr_user_side_to_increase_length=split(',',$user_side_to_increase_length);
						
						foreach my $side_and_bases(@arr_user_side_to_increase_length)
							{			
						
								if($side_and_bases!~/NA/)
									{
										my($u_side_to_increase_length,$u_no_of_bases_to_increase_length)=split('-',$side_and_bases);
										#---------------------------------------------------------------
										
										my $case_found=0;	
										undef @modified_array;
										($model_repeat,$case_found)=&increase_all_repeat_lengths($range,$u_side_to_increase_length,$u_no_of_bases_to_increase_length,$accession,$model_repeat,\@current_array,\@modified_array);
										
										
										if($case_found==1)
											{
												#------------ complete the @modified array ---
												for(my $m=3;$m>=0;$m--)
													{
														unshift(@modified_array,$current_array[$m]);
														#shift(@modified_array);
													}
												push(@modified_array,$current_array[$#current_array]);
													
												@current_array=@modified_array;
												
												#undef @modified_array;
												$atleast_one_operation_performed++;
											}
											
										undef @modified_array;	
									}	
							
								else{							#----- auto check with $repeat_extension_identity
								
										#system("echo '$repeat_extension_identity' >log.txt");
										
										my $case_found1=0;	
										my $sides_to_increase_length="NA-0,";
										undef @modified_array;
										
										($sides_to_increase_length,$case_found1)=&auto_detect_repeat_sides_and_bases_to_increase($range,$repeat_extension_identity,$accession,$model_repeat,\@current_array,\@modified_array); # special cases: $repeat_extension_identity set to 50
										
										#print "$sides_to_increase_length,$case_found1\n";
										
										if($case_found1==1)
											{
												
												my @arr_sides_to_increase_length=split(',',$sides_to_increase_length);									
												
												foreach my $side_and_bases(@arr_sides_to_increase_length)
													{			
														#system("echo '$side_and_bases' >log.txt");
														
														if($side_and_bases!~/NA/)
															{
																my($side_to_increase_length,$no_of_bases_to_increase_length)=split('-',$side_and_bases);
																#---------------------------------------------------------------
																
																my $case_found=0;	
																
																($model_repeat,$case_found)=&increase_all_repeat_lengths($range,$side_to_increase_length,$no_of_bases_to_increase_length,$accession,$model_repeat,\@current_array,\@modified_array);
																
																
																if($case_found==1)
																	{
																		#------------ complete the @modified array ---
																		for(my $m=3;$m>=0;$m--)
																			{
																				unshift(@modified_array,$current_array[$m]);
																				#shift(@modified_array);
																			}
																		push(@modified_array,$current_array[$#current_array]);
																			
																		@current_array=@modified_array;
																		
																		#undef @modified_array;
																		$atleast_one_operation_performed++;
																	}
																	
																undef @modified_array;	
															}
													}		
											}
											
										undef @modified_array;	
									}	
							
							}	
					
						
						#----- check for misaligned bases
						#&fix_ array_with_falsely_identified_repeats($accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);	 --- use in general
						&check_array_for_misaligned_bases($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
						
					}
				
				#print "2: After increase_repeat_length:\n";		
				#&print_array($model_repeat,\@current_array);
				#----------------------------------------------------------	

				if($remove_insertion_from_repeat==1 and $model_repeat=~/-/)
					{

						
						my $case_found=0;
						($model_repeat,$case_found)=&fix_arrays_with_insertion_in_repeat($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
						
						
						if($case_found==1)
							{
								$atleast_one_operation_performed++;
							}
						
			
						undef @modified_array;	
					}
				#next;
				
				if($check_consensus==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
					{
						#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
						
						my $case_found=0;	
						($model_repeat,$case_found)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
						
						
						if($case_found==1)
							{
								$atleast_one_operation_performed++;
							}
						undef @modified_array;				
					}
				
				
				
				#-------
				#print "2: Before trim_repeats:\n";	
				#&print_array($model_repeat,\@current_array);
				
				
				
				my $tmp_minimum_repeat_length=21;
				if($trim_repeats==1 and length($model_repeat)>$tmp_minimum_repeat_length)######### $trimming_cutoff set to high ( 20 ) ; $minimum_repeat_length set to 24
					{
						#--- check if the ATTGAAAC motif is likely present at either  side --
						my $motif_likely_present_at_left=0;
						my $motif_likely_present_at_right=0;
						
						if($model_repeat=~/ATTGAAAC(\S{1,5})$/)
							{
								$motif_likely_present_at_right=1;
								my $extra_bases_right=$1;
								my $extra_bases_right_len=length($extra_bases_right);	
								$user_side_to_trim="RIGHT-$extra_bases_right_len,NA";							
							}
						elsif($model_repeat=~/^(\S{1,5})GTTTCAAT/)
							{
								$motif_likely_present_at_left=1;
								my $extra_bases_left=$1;
								my $extra_bases_left_len=length($extra_bases_left);
								$user_side_to_trim="LEFT-$extra_bases_left_len,NA";	
							}
						
						my @arr_user_sides_to_trim=split(',',$user_side_to_trim);
						
						foreach my $side_and_bases(@arr_user_sides_to_trim)
							{
								
								my $case_found=0;				
								
								($model_repeat,$case_found)=&trim_repeat_ends_and_improve_score($range,$tmp_minimum_repeat_length,$side_and_bases,$trimming_cutoff,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
								
								
								if($case_found==1)
									{
										$atleast_one_operation_performed++;
									}
								
								
								if($case_found==1)
									{	
										
										if($side_and_bases=~/NA/)
											{
												undef @modified_array;							
												for(my $m=3;$m>=0;$m--)
													{
														unshift(@modified_array,$current_array[$m]);
													}
												
												my $case_found1=0;
												($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
												
												
												push(@modified_array,$current_array[$#current_array]);
																				
												
												if($case_found1==1)	{@current_array=@modified_array;}								
															
												undef @modified_array;	
											}

								}
									
										
								undef @modified_array;
							}
						
					}
			
				#print "3: After trim_repeats:\n";		
				#&print_array($model_repeat,\@current_array);
				#----------------------------------------------------------	
			
				###################################### END of Special cases ################################################################################

				&fix_array_with_falsely_identified_repeats($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);	



				################################# the following block is really important to handle mis representation of CRISPRs [e.g. wrongly ]-------------------------------------------------------------------
								
				my($total_repeats,$total_mutations_in_repeats,$p_repeats_with_mutations,$median_spacer_length,$exceptionally_long_spacer_found,$side_to_shorten)=&check_array_sanity(\@current_array);
				
				
								
				
				if($total_repeats >2 and ($total_mutations_in_repeats > $total_repeats*3 or $p_repeats_with_mutations >=30 or $exceptionally_long_spacer_found==1))
					{
						#print "Before finalizing:\n";		
						#&print_array($model_repeat,\@current_array);
						
						#--- now check if exceptionally long spacer is found
						if($total_repeats >2 and $exceptionally_long_spacer_found==1)
							{
								my @modified_array;
								#print "@current_array\n";	
										my $case_found=0;	
										
										my $tmp_minimum_no_of_repeats=2;		
										($case_found)=&shorten_array($range,$tmp_minimum_no_of_repeats,$sa_allowed_percent_similarity,$side_to_shorten,$accession,$model_repeat,$median_spacer_length,\@current_array,\@modified_array);
										
										

										
										if($case_found==1)
											{
												for(my $m=3;$m>=0;$m--)
													{
														unshift(@modified_array,$current_array[$m]);
														#shift(@modified_array);
													}
												push(@modified_array,$current_array[$#current_array]);	
												
												

												
												@current_array=@modified_array;
												$atleast_one_operation_performed++;
											}
										
										
										undef @modified_array;
							}
						
						
						
						#--- check if trimming is needed
						if($total_repeats >2 and ($total_mutations_in_repeats > $total_repeats*3 or $p_repeats_with_mutations >=30))
							{
								my @modified_array;
								#if($trim_repeats==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
								#				{									
													my @arr_user_sides_to_trim=split(',',$user_side_to_trim);
													
													foreach my $side_and_bases(@arr_user_sides_to_trim)
														{
															
															my $case_found=0;				
															#$minimum_repeat_length=11;
															my $tmp_trimming_cutoff=20;
															($model_repeat,$case_found)=&trim_repeat_ends_and_improve_score($range,$minimum_repeat_length,$side_and_bases,$tmp_trimming_cutoff,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
															
															#print "\t$model_repeat,$case_found\n";
															if($case_found==1)
																{
																	$atleast_one_operation_performed++;
																}
															
															
															if($case_found==1)
																{	
																	
																	if($side_and_bases=~/NA/)
																		{
																			undef @modified_array;							
																			for(my $m=3;$m>=0;$m--)
																				{
																					unshift(@modified_array,$current_array[$m]);
																				}
																			
																			my $case_found1=0;
																			($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
																			
																			
																			push(@modified_array,$current_array[$#current_array]);
																											
																			
																			if($case_found1==1)	{@current_array=@modified_array;}								
																						
																			undef @modified_array;	
																		}

															}
																
																	
															undef @modified_array;
														}									
								#				}
							}
						
						
						
						#print "After fixing:\n";		
						#&print_array($model_repeat,\@current_array);
					}
				######################################################


				#----------- check potential alternate repeat -----------------------------------------	
				#print "Going to check potential alternate repeat\n";
					
				if($find_alternate_repeat==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
					{
						#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
						
						my $case_found=0;	
						($model_repeat,$potential_alternate_repeat,$case_found)=&search_alternate_repeat_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
						
						
						if($case_found==1)
							{
								$atleast_one_operation_performed++;
							}
							
						undef @modified_array;	
					}

			

				#################################---------- check direction of the array ---------------------------------------------

				my $direction_found=0;
				my $array_direction="NA";
				my $repeat_family="NA";
				my $matching_reference_repeat="NA";
				my $array_direction_MEMO="NA";
				
				#print "Going to check direction\n";
				
				if($check_direction==1)
					{
									
						
						
						#---- note: array start and stop position is require for Longer leader analysis: find them here which is different from CRISPRDetect.pl --------
						
						my($array_start_position,$array_stop_position,$avg_spacer_length)=&find_array_start_stop_position($array_direction,\@current_array);

						
						#-------------------------------------------------------------------------------
						my $case_found=0;	
						my $matching_reference_repeat_direction="NA";
						
						#($matching_reference_repeat,$model_repeat,$array_direction,$repeat_family,$array_direction_MEMO,$case_found)=&check_array_direction($accession,$model_repeat,$avg_spacer_length,$all_gene_positions_folder,$all_gene_positions_file,\@current_array,\@modified_array,\%lib_of_repeats_with_confirmed_direction);
						($matching_reference_repeat,$matching_reference_repeat_direction,$model_repeat,$array_direction,$repeat_family,$array_direction_MEMO,$case_found)=&check_array_direction($range,$blast_db_file_of_known_repeats,$check_motif_in_repeat,$motif,$check_A_and_T_ratio_in_repeat,$check_similarity_with_reference_repeat,$allowed_no_of_mismatches,$check_secondary_structure_of_repeat,$MFE_cutoff,$MFE_minimum_difference,$MFE_exclude_bases,$check_array_degeneracy,$permitted_mutation_per_array,$check_AT_distribution_in_flanks,$AT_distribution_window,$AT_distribution_minimum_percentage_difference,$check_longer_leader,$Motif_match_score,$A_and_T_ratio_score,$Similarity_score,$MFE_score,$array_degeneracy_score,$AT_distribution_score,$Longer_leader_score,$array_start_position,$array_stop_position,$accession,$model_repeat,$all_gene_positions_folder,$all_gene_positions_file,\%lib_of_repeats_with_confirmed_direction,\@current_array,\@modified_array);
						
						
						my $model_repeat_rc=$model_repeat;$model_repeat_rc=reverse $model_repeat_rc;$model_repeat_rc=~tr/ACGTU/TGCAA/;
						
						if($matching_reference_repeat !~ /^NA/ and ($matching_reference_repeat_direction =~/^$array_direction/ or $array_direction =~/^$matching_reference_repeat_direction/))
							{
								
								#-------- align the model repeat and the reference repeat first, and get the positions of match ---
								my $b_sequence=$matching_reference_repeat;
								if($array_direction=~/R/)
									{
										$b_sequence= reverse $b_sequence;
										$b_sequence=~tr/ACGT/TGCA/;
									}
										
								my($m_repeat_line,$r_repeat_line)=&get_aligned_region_start_stop($range,$accession,$model_repeat,$b_sequence);
										
								#system("echo '$m_repeat_line,$r_repeat_line' >>log1.txt");
								
								
								#---- check $m_repeat_line: to extend the repeats
								if($m_repeat_line=~/^-/ or $m_repeat_line=~/-$/)
									{
										my $side_to_increase_length;
										my $no_of_bases_to_increase_length;
										#-----Check left -----------------------------------------------
										if($m_repeat_line=~/^(\-+)/)
											{									
												$no_of_bases_to_increase_length=length($1);
												$side_to_increase_length="LEFT";
												
												my $case_found1=0;	
												undef @modified_array;
												($model_repeat,$case_found1)=&increase_all_repeat_lengths($range,$side_to_increase_length,$no_of_bases_to_increase_length,$accession,$model_repeat,\@current_array,\@modified_array);
																					
												#------------ complete the @modified array ---
												for(my $m=3;$m>=0;$m--){unshift(@modified_array,$current_array[$m]);}
												push(@modified_array,$current_array[$#current_array]);
															
												@current_array=@modified_array;
											}
										
										#------ check right ----------------------------------------------
										if($m_repeat_line=~/(\-+)$/)
											{									
												$no_of_bases_to_increase_length=length($1);
												$side_to_increase_length="RIGHT";
												
												my $case_found1=0;	
												undef @modified_array;
												($model_repeat,$case_found1)=&increase_all_repeat_lengths($range,$side_to_increase_length,$no_of_bases_to_increase_length,$accession,$model_repeat,\@current_array,\@modified_array);
																					
												#------------ complete the @modified array ---
												for(my $m=3;$m>=0;$m--){unshift(@modified_array,$current_array[$m]);}
												push(@modified_array,$current_array[$#current_array]);
															
												@current_array=@modified_array;
											}
											
										if($model_repeat=~/-/)
											{
												my $case_found_t1=0;	
												($model_repeat,$case_found_t1)=&check_consensus_sequence($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
											}										
										undef @modified_array;	
									}		
								#---- check $r_repeat_line: to trim the repeats
								if($r_repeat_line=~/^-/ or $r_repeat_line=~/-$/)
									{
										my $side_and_bases;										
										my $no_of_bases_to_trim;
												
										#---- first left side ----------------------------------------
										if($r_repeat_line=~/^(\-+)/)
											{
												$no_of_bases_to_trim=length($1);	
												
												
												my $case_found1=0;
												$side_and_bases="LEFT-$no_of_bases_to_trim";
												
												($model_repeat,$case_found1)=&trim_repeat_ends_and_improve_score($range,$minimum_repeat_length,$side_and_bases,$trimming_cutoff,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
														
												undef @modified_array;
											}
										#---- right side ----------------------------------------
										if($r_repeat_line=~/(\-+)$/)
											{
												$no_of_bases_to_trim=length($1);	
												
												
												my $case_found1=0;
												$side_and_bases="RIGHT-$no_of_bases_to_trim";
												
												($model_repeat,$case_found1)=&trim_repeat_ends_and_improve_score($range,$minimum_repeat_length,$side_and_bases,$trimming_cutoff,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
														
												undef @modified_array;
											}	
									}		

														
								$direction_found++;
								$atleast_one_operation_performed++;
							}
						
						elsif($model_repeat=~/ATTGAAA.?\w{0,3}/ or $model_repeat_rc=~/ATTGAAA.?\w{0,3}/)
							{
									my $side_and_bases="NA-0,";										
									my $no_of_bases_to_trim;
												
							
									if($model_repeat=~/ATTGAAA.?(\w{0,3})$/)
										{
											#print "Inside..\n";
											$no_of_bases_to_trim=length($1);
											$side_and_bases="RIGHT-$no_of_bases_to_trim";	
										}		
									elsif($model_repeat_rc=~/ATTGAAA.?(\w{0,3})$/)
										{
											$no_of_bases_to_trim=length($1)-1; # left side starts from zero
											$side_and_bases="RIGHT-$no_of_bases_to_trim";
										}			
									
									
									
									if($side_and_bases!~/NA/)
										{
											my $case_found1=0;										
												
											($model_repeat,$case_found1)=&trim_repeat_ends_and_improve_score($range,$minimum_repeat_length,$side_and_bases,$trimming_cutoff,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
														
											undef @modified_array;
										}	
										
										
							}
						

						undef @modified_array;	
					}

				
				&check_array_for_misaligned_bases($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
				#print "Done\n";
				



				#---------- get array_quality score
				#my $species="Bacteria";
				if($hash_of_accession_and_species{$accession})
					{
						$species=$hash_of_accession_and_species{$accession};
					}
				my($array_quality_score,$score_det,$score_legend)=&calculate_array_quality_score($range,$species,$accession,$all_gene_positions_folder,$all_gene_positions_file,$matching_reference_repeat,$model_repeat,\@current_array);
				$array_quality_score= sprintf("%.2f",$array_quality_score);
				
			
				
				#print "$range: \$array_quality_score=$array_quality_score\n";
				#------- double check the arrays, where score is close to 0
				if($array_quality_score<1 and $array_quality_score > -1.50)   ### remove degenerated repeats from either end to improve score
					{
						#---------- remove poor/degenerated repeats from either ends ------------

						if($shorten_array==1)
							{
								
								#print "@current_array\n";	
								my $case_found=0;	
										
								($case_found)=&shorten_array($range,$minimum_no_of_repeats,$sa_allowed_percent_similarity,$user_side_to_shorten,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
								
								

								
								if($case_found==1)
									{
										for(my $m=3;$m>=0;$m--)
											{
												unshift(@modified_array,$current_array[$m]);
												#shift(@modified_array);
											}
										push(@modified_array,$current_array[$#current_array]);	
										
										

										
										@current_array=@modified_array;
										$atleast_one_operation_performed++;
									}
								
								
								undef @modified_array;
							}
						
						
						if($trim_repeats==1 and length($model_repeat)>25)######### $trimming_cutoff set to high ( 20 ) ; $minimum_repeat_length set to 24
							{
								
								
								my @arr_user_sides_to_trim=split(',',$user_side_to_trim);
								
								foreach my $side_and_bases(@arr_user_sides_to_trim)
									{
										
										my $case_found=0;				
										my $tmp_minimum_repeat_length=24;
										my $tmp_trimming_cutoff=20;
										($model_repeat,$case_found)=&trim_repeat_ends_and_improve_score($range,$tmp_minimum_repeat_length,$side_and_bases,$tmp_trimming_cutoff,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
										
										
										if($case_found==1)
											{
												$atleast_one_operation_performed++;
											}
										
										
										if($case_found==1)
											{	
												
												if($side_and_bases=~/NA/)
													{
														undef @modified_array;							
														for(my $m=3;$m>=0;$m--)
															{
																unshift(@modified_array,$current_array[$m]);
															}
														
														my $case_found1=0;
														($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
														
														
														push(@modified_array,$current_array[$#current_array]);
																						
														
														if($case_found1==1)	{@current_array=@modified_array;}								
																	
														undef @modified_array;	
													}
												#print "\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n";	
												#for(my $k1=0;$k1<=$#original_array;$k1++)
												#	{
												#		print "$original_array[$k1]\n";
												#	} 			
												#print "\n";
												
												#print "Repeat ends trimming operation for $accession:\n\n";
												
												#foreach my $l(@current_array)
												#	{
												#		print "$l\n";
												#	}
												#print "\$model_repeat=$model_repeat\n\n";
												
												#print "\nLF: $left_flank_seq\nRF: $right_flank_seq\n";	
												
												#--- check if the insertion is already handled and removed or not
												#if($model_repeat!~/-/)
												#	{
												#		#$insertion_found_in_repeat=0;
												#	}
										}
											
												
										undef @modified_array;
									}
								
							}
					
					
						if($increase_repeat_length==1 and length($model_repeat)<24)
							{
								#system("echo '$user_side_to_increase_length' >log.txt");
								my @arr_user_side_to_increase_length=split(',',$user_side_to_increase_length);
								
								foreach my $side_and_bases(@arr_user_side_to_increase_length)
									{			
								
										if($side_and_bases!~/NA/)
											{
												my($u_side_to_increase_length,$u_no_of_bases_to_increase_length)=split('-',$side_and_bases);
												#---------------------------------------------------------------
												
												my $case_found=0;	
												undef @modified_array;
												($model_repeat,$case_found)=&increase_all_repeat_lengths($range,$u_side_to_increase_length,$u_no_of_bases_to_increase_length,$accession,$model_repeat,\@current_array,\@modified_array);
												
												
												if($case_found==1)
													{
														#------------ complete the @modified array ---
														for(my $m=3;$m>=0;$m--)
															{
																unshift(@modified_array,$current_array[$m]);
																#shift(@modified_array);
															}
														push(@modified_array,$current_array[$#current_array]);
															
														@current_array=@modified_array;
														
														#undef @modified_array;
														$atleast_one_operation_performed++;
													}
													
												undef @modified_array;	
											}	
									
										else{							#----- auto check with $repeat_extension_identity
										
												#system("echo '$repeat_extension_identity' >log.txt");
												
												my $case_found1=0;	
												my $sides_to_increase_length="NA-0,";
												
												undef @modified_array;
												
												($sides_to_increase_length,$case_found1)=&auto_detect_repeat_sides_and_bases_to_increase($range,$repeat_extension_identity,$accession,$model_repeat,\@current_array,\@modified_array); # special cases: $repeat_extension_identity set to 50
												
												print "$sides_to_increase_length,$case_found1\n";
												
												if($case_found1==1)
													{
														
														my @arr_sides_to_increase_length=split(',',$sides_to_increase_length);									
														
														foreach my $side_and_bases(@arr_sides_to_increase_length)
															{			
																#system("echo '$side_and_bases' >log.txt");
																
																if($side_and_bases!~/NA/)
																	{
																		my($side_to_increase_length,$no_of_bases_to_increase_length)=split('-',$side_and_bases);
																		#---------------------------------------------------------------
																		
																		my $case_found=0;	
																		
																		($model_repeat,$case_found)=&increase_all_repeat_lengths($range,$side_to_increase_length,$no_of_bases_to_increase_length,$accession,$model_repeat,\@current_array,\@modified_array);
																		
																		
																		if($case_found==1)
																			{
																				#------------ complete the @modified array ---
																				for(my $m=3;$m>=0;$m--)
																					{
																						unshift(@modified_array,$current_array[$m]);
																						#shift(@modified_array);
																					}
																				push(@modified_array,$current_array[$#current_array]);
																					
																				@current_array=@modified_array;
																				
																				#undef @modified_array;
																				$atleast_one_operation_performed++;
																			}
																			
																		undef @modified_array;	
																	}
															}		
													}
													
												undef @modified_array;	
											}	
									
									}	
							
								
								#----- check for misaligned bases
								&check_array_for_misaligned_bases($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
							}			
								
						#--- and re-check the quality score again
						($array_quality_score,$score_det,$score_legend)=&calculate_array_quality_score($range,$species,$accession,$all_gene_positions_folder,$all_gene_positions_file,$matching_reference_repeat,$model_repeat,\@current_array);
						$array_quality_score= sprintf("%.2f",$array_quality_score);
						
					}
					
				
				
				
				
				#################### ask user if they want to see extra degenerated spacer (if present) using 75% identity
				
				if($extend_array==10 and length($model_repeat)>=$word_length)           #--- not useful: suppressed by ambarish 14-Aug-2018
					{
						
						#@modified_array=@current_array;
						#for(my $m=3;$m>=0;$m--)
						#	{
						#		#unshift(@modified_array,$current_array[$m]);
						#		shift(@modified_array);
						#	}
						#pop(@modified_array);
						
						#print "@current_array\n";	
						#print "Before:\n";
						#foreach my $l(@current_array)
						#	{
						#		print "$l\n";
						#	}
						#print "\t$model_repeat\n";	
						
						
						my $case_found=0;	
								
						($case_found)=&extend_array($range,$max_gap_between_crisprs,$ea_dynamic_search,$ea_allowed_percent_similarity,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
						
						#print "\n******** \$case_found=$case_found *********\n";
						
						if($case_found==1)
							{
								$atleast_one_operation_performed++;
							}
						
						if($case_found==1)
							{
								for(my $m=3;$m>=0;$m--)
									{
										unshift(@modified_array,$current_array[$m]);
										#shift(@modified_array);
									}
								push(@modified_array,$current_array[$#current_array]);	
										
								@current_array=@modified_array;
								undef @modified_array;
								
								#print "After:\n";
								#foreach my $l(@current_array)
								#	{
								#		print "$l\n";
								#	}
								#print "\t$model_repeat\n";	
								
								#------- fix the gaps ---------------------------------
								for(my $m=3;$m>=0;$m--)
									{
										unshift(@modified_array,$current_array[$m]);
									}
								
								my $case_found1=0;
								($case_found1)=&fix_arrays_with_gaps($range,$accession,$model_repeat,$avg_spacer_length,\@current_array,\@modified_array);
								
							
								if($case_found1==1)
									{
										push(@modified_array,$current_array[$#current_array]);
										@current_array=@modified_array;	
										$atleast_one_operation_performed++;
									}
											
								undef @modified_array;	
								
							}
						
						
						undef @modified_array;
					}

							
				#----- skip is length or model_repeat too short, or q_score is too low
				if(($#current_array+1-5) < 3 and (length($model_repeat)< 17 ) or (($#current_array+1-5)<3 and $array_quality_score< -3)  or (length($model_repeat)< 17 and $array_quality_score< -3 ))
					{
						#next;
						if($mode eq "FASTA")
							{
								if($skip_process_management==0)
									{
										&update_process_list_file_of_accession_and_range($process_list_file_of_accession_and_range,$accession,$range,'0');
									}	
								$pm->finish;
							}
					}
						
				if($quiet!=1 and $array_quality_score>=0)
					{		
						print "\t  Array_quality_score= $array_quality_score\n";
					}
				
				
				
				
				
				
				
				
					
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
					
				#----------------- Very Important: save a copy of the @current_array : will be used for gff creation ----------
				my @backup_current_array=@current_array;
				
					
				#----------- reverse the array ---------------------------------------------------------
				
				if($user_reverse_the_array==1){$array_direction = "R";}
				if($array_direction =~ /R/)
					{
						my $case_found=0;	
						($model_repeat,$case_found)=&revers_an_array($range,$accession,$model_repeat,\@current_array,\@modified_array);
						
						
						if($case_found==1)
							{
								if($potential_alternate_repeat ne "NA")
									{
										$potential_alternate_repeat=reverse $potential_alternate_repeat; $potential_alternate_repeat=~tr/ACGT/TGCA/;
									}
									
								
								#------------ complete the @modified array ---
								for(my $m=3;$m>=0;$m--)
									{
										unshift(@modified_array,$current_array[$m]);
										#shift(@modified_array);
									}
								push(@modified_array,$current_array[$#current_array]);
									
								@current_array=@modified_array;
								
								#undef @modified_array;	
								$atleast_one_operation_performed++;
							}
						undef @modified_array;	
					}
				



				
				



						
				
				
				#---- finally finalize the array with fixing Deletion texts --------------------
				my $finalize_array=1;
				my $questionable_array=0;
				my $array_start_position=0;
				my $array_stop_position=0;
				
				if($finalize_array==1)#if($gap_found_in_repeat==1 or $insertion_found_in_repeat==1)
					{
						#print "\nA1: $left_flank_seq\nA2: $right_flank_seq\n\n";
						
						my $case_found=0;

						#undef @backup_current_array;
						#@backup_current_array=@current_array;
							
						($model_repeat,$potential_alternate_repeat,$questionable_array,$array_start_position,$array_stop_position,$case_found)=&finalize_the_array($range,$array_quality_score,$score_det,$score_legend,$all_gene_positions_folder,$all_gene_positions_file,$array_direction,$matching_reference_repeat,$repeat_family,$array_direction_MEMO,$potential_alternate_repeat,$accession,$model_repeat,$avg_spacer_length,$left_flank_length,$right_flank_length,\@current_array,\@modified_array);
						
						
						if($case_found==1)
							{
								$atleast_one_operation_performed++;
							}								
					}
				
				#print "All done\n";
				
				

				
				my ($array_already_exist,$existing_array_q_score)=&check_array_existance($array_quality_score,$array_start_position,$array_stop_position,$tmp_output_file);
				if($array_already_exist==1)
					{
						if($quiet!=1 and $array_quality_score>=0)
							{
								#print "\t\tAlready part of previously processed Array. Skipping...\n";
							}	
						
						if($mode eq "FASTA")
							{
								if($skip_process_management==0)
									{
										&update_process_list_file_of_accession_and_range($process_list_file_of_accession_and_range,$accession,$range,'0');
									}	
								$pm->finish; 
							}
					}
				
				#$minimum_no_of_repeats $minimum_repeat_length
				
				#---- check if the DR matched any reference DR or not			
				my @arr_s1=split(', ',$score_det);
				#print "\$arr_s1[1]=$arr_s1[1] \t\$matching_reference_repeat=$matching_reference_repeat\n";
				
				my $matched_reference_repeat=0;
				if($arr_s1[1]=~/2:3$/){$matched_reference_repeat=1;}
				
					
				if($array_already_exist==0 and ($array_quality_score>=$array_quality_score_cutoff and length($model_repeat)>=$minimum_repeat_length and ($#backup_current_array+1-5) >= $minimum_no_of_repeats) or (($#backup_current_array+1-5) >=2 and $matched_reference_repeat==1 and $array_quality_score>=$array_quality_score_cutoff))
					{	
						#--------- append the positions of spacer and repeats in the GFF file ------------------------------------------------------------------------------------------
						my($array_start_pos1,$array_stop_pos1,$avg_spacer_len1)=&find_array_start_stop_position('F',\@backup_current_array);			
						&create_gff_file($gff_file,$array_direction,$crispr_index,$array_start_pos1,$array_stop_pos1,$accession,$model_repeat,\@backup_current_array,\@modified_array,\%hash_id_lookup_table);
						
						
						my $current_array_content=join("&&&",@current_array);
						
						open(APP,">>$tmp_dir\/$tmp_output_file") or print "$!";
						flock(APP,2);
						print APP "$accession%%%$array_start_position%%%$array_stop_position%%%$array_quality_score%%%$current_array_content\n";
						close(APP);

									
						$crispr_index++;
					}			
				elsif($array_already_exist==0 and $array_quality_score>=0 and length($model_repeat)>=$repeat_length_cutoff)
					{
						#----- dump the poor arrays in junkfile
						
						open(FP,">>$filtered_out_crisprs");
						flock(FP,2);
						print FP "Array 0 0-0 \t\t**** Predicted by CRISPRDetect $version *** \n";
						my $fp_array=join("\n",@current_array);
						if(defined $hash_id_lookup_table{$accession})
						{
							$fp_array=~s/($accession)\|?/$hash_id_lookup_table{$accession}/g;
						}	
						
						print FP "$fp_array\n\n";
						close(FP);
					}

						
				#---------------------------------------------------------------------------------	

			}
				
			
			
			
			
			######################### store the range to the process_list_file_of_accession_and_range file to prevent other processors to simulteniously process putative CRISPR belongs to same range ##
			
			
			#open(APP,">>$process_list_file_of_accession_and_range");
			#flock(APP,2);
			#print APP "$accession\t$range\t1\n";
			#close(APP);
			##################################################################################################################################################################
			
			
			undef @current_array;	
				
			if($mode eq "FASTA")
				{
					if($skip_process_management==0)
						{
							if($not_a_crispr==1)
								{
									&update_process_list_file_of_accession_and_range($process_list_file_of_accession_and_range,$accession,$range,'-1');
								}
							else{
									&update_process_list_file_of_accession_and_range($process_list_file_of_accession_and_range,$accession,$range,'0');
								}
						}			
						
					$pm->finish;
				}
				
					
		
		}#end of range


		
		if($continue_from_last_process ==1)
			{
				#---- add the current accession to continue file -------------------
				open(ADD,">>$tmp_dir\/$continue_from_last_process_file");
				flock(ADD,2);
				print ADD "$accession\n";
				close(ADD);
				#-------------------------------------------------------------------
			}
		
		if($mode eq "FASTA")
			{
				$pm->wait_all_children;
			}


 
		#-------------------- now load the arrays in %hash_of_arrays_per_accession -----------------------------------------------------
		open(RD4,"$tmp_dir\/$tmp_output_file") or print "$!";
		flock(RD4,2);
		my @arr_rd4=<RD4>;
		close(RD4);
		foreach my $line(@arr_rd4)
			{
				my @arr_line=split('%%%',$line);
				my $accession=$arr_line[0];
				my $start=$arr_line[1];
				my $stop=$arr_line[2];
				my $q_score=$arr_line[3];
				my $existing_array=$arr_line[4];
				
				if(defined $start and defined $stop and defined $existing_array)
					{			
						$hash_of_arrays_per_accession{$start}{$stop}=$existing_array;						
					}	
			}
		


		#-------------------- now print the array(s) for the current accession accession -----------------------------------------------
		#print "\n\nCRISPRDetect output:\n\n";	
		
		my %hash_of_accessions_of_predicted_crisprs;
		
		open(WR,">>$output_file");
		flock(WR,2);
		my $array_index=1;
		
			
		foreach my $start_pos(sort{$a<=>$b} keys %hash_of_arrays_per_accession)
			{
				foreach my $stop_pos(sort{$a<=>$b} keys %{$hash_of_arrays_per_accession{$start_pos}})
					{
								$hash_of_accessions_of_predicted_crisprs{$accession}=1;
								
								
								#print "$hash_of_arrays_per_accession{$start_pos}{$stop_pos}\n\n";
								print WR "Array $array_index $start_pos-$stop_pos \t\t**** Predicted by CRISPRDetect $version *** \n";
								
								my $cd_array=$hash_of_arrays_per_accession{$start_pos}{$stop_pos};
								
								if(defined $hash_id_lookup_table{$accession})
									{
										$cd_array=~s/($accession)\|?/$hash_id_lookup_table{$accession}/g;
									}	
								
								$cd_array=~s/&&&/\n/g;
								#print "$1\n";
								print WR "$cd_array\n\n";
								$array_index++
					}
			}
	
		close(WR);
		
		unlink("$tmp_dir\/$tmp_output_file");		
	
	
		#########################################---- the code to identify degenerated CRISPR (i.e. using the DRs from existig good CRISPRs in the sequence )  should go here ---
	
	
		#---------------------------------------------------------------------------------------------------------------------------------
	
	
	
	
	
	
	
		#------- delete files not needed anymore ----
		if($keep_input_sequences==1 and $hash_of_accessions_of_predicted_crisprs{$accession})
			{
				open(SEQ,">$tmp_dir\/$accession\.fna");
				flock(SEQ,2);
				print SEQ ">$accession\n$hash_of_seq_id_and_seq{$accession}\n";
				close(SEQ);			
			}	
		elsif(-e "$tmp_dir\/$accession\.fna")
			{			
				unlink("$tmp_dir\/$accession\.fna");				
			}
		
		#--------------------------------------------
		if($mode eq "multiFASTA")
			{
				$pm->finish;
			}
	} # End of foreach my $accession

if($mode eq "multiFASTA")
	{ 
		$pm->wait_all_children;
	}

#---- finally create a multiFasta spacers file ----------------
my $spacer_file=$output_file.".spacers.fa";
&extract_spacers($output_file,$spacer_file,"CRISPRDetect");	


if($blast_db_file_of_known_repeats=~/^$tmp_dir/)
	{
		#print "\n\nRemoving all files associated to $blast_db_file_of_known_repeats\n\n";
		system("rm $blast_db_file_of_known_repeats\*");
		
	}


#----- clean $tmp_dir\/ folder --------------- 
#unlink<$tmp_dir\/*\.mfe>;
#unlink<$tmp_dir\/mr_*\.txt>;

#print "\n\nall_gene_positions_file = $tmp_dir\/$all_gene_positions_file\n\n";
#unlink("$tmp_dir\/$all_gene_positions_file");

if(-e $process_list_file_of_accession_and_range){system("rm $process_list_file_of_accession_and_range");}

#foreach my $seq_file(@arr_sequence_files)
#	{
#		#print "\$seq_file=$seq_file\n";
		if($keep_input_sequences==0)
			{
				if($tmp_dir ne "/tmp")
					{
						system("rm -rf $tmp_dir");
					}
			}			
#	}
	




#print "\nAll done. :)\n\n";








##################################################################### subs #############################################################

sub get_path()
	{
		my $dir=shift(@_);
		my @arr_p1=split('\/',$cd_path);
		pop(@arr_p1);
		$dir=join("\/",@arr_p1);
		
		return $dir;
	}





############################################################### end of subs #################################################################	
